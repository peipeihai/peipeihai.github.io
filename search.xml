<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>javascript中的代理与反射</title>
    <url>/2021/06/28/javascript/javascript%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>ECMAScript6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<h1 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h1><h2 id="创建代理"><a href="#创建代理" class="headerlink" title="创建代理"></a>创建代理</h2><p>代理是使用 Proxy 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。</p>
<pre><code>const target = &#123; id: &#39;target&#39; &#125;;
const handler = &#123;&#125;;

const proxy = new Proxy(target, handler);

console.log(target.id); // target
console.log(proxy.id); // target

// 给目标赋值也会反映到代理上，两者引用的是同一个对象
target.id = &#39;foo&#39;;
console.log(target.id); // foo
console.log(proxy.id); // foo

// 给代理赋值同样也会反映到目标上
proxy.id = &#39;bar&#39;;
console.log(target.id); // bar
console.log(proxy.id); // bar

console.log(target.hasOwnProperty(&#39;id&#39;)); // true
console.log(proxy.hasOwnProperty(&#39;id&#39;)); // true
</code></pre>
<h2 id="定义捕获器"><a href="#定义捕获器" class="headerlink" title="定义捕获器"></a>定义捕获器</h2><p>使用代理的主要目的是可以定义捕获器（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。</p>
<pre><code>注： 捕获器（trap）是从操作系统中借用的概念。在操作系统中，捕获器是程序流中的一个同步中断，可以暂停程序流，转而执行一段子例程，之后再返回原始程序流。
</code></pre>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const handler = &#123;
  get() &#123;
    return &#39;handler override&#39;;
  &#125;,
&#125;;
const proxy = new Proxy(target, handler);

// 注意，只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正常的行为。
console.log(proxy.foo); // handler override
console.log(target.foo); // bar
</code></pre>
<h2 id="捕获器参数和反射-API"><a href="#捕获器参数和反射-API" class="headerlink" title="捕获器参数和反射 API"></a>捕获器参数和反射 API</h2><p>所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如，get()捕获器会接收到目标对象、要查询的属性和代理对象三个参数。</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const handler = &#123;
  get(trapTarget, property, receiver) &#123;
    console.log(target === trapTarget);
    console.log(property);
    console.log(receiver === proxy);

    // 有了这些参数，就可以重建被捕获方法的原始行为
    return trapTarget[property];
  &#125;,
&#125;;
const proxy = new Proxy(target, handler);
console.log(proxy.foo);
// true
// foo
// true
// bar
</code></pre>
<p>所有捕获器都可以基于自己的参数重建原始操作，但并非所有捕获器行为都像 get()那么简单。因此，通过手动写码如法炮制的想法是不现实的。实际上，开发者并不需要手动重建原始行为，而是可以通过调用全局 Reflect 对象上（封装了原始行为）的同名方法来轻松重建。处理程序对象中所有可以捕获的方法都有对应的反射（Reflect）API 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const handler = &#123;
  get() &#123;
    return Reflect.get(...arguments);
  &#125;,
  // 甚至可以使用更简洁的写法
  // get: Reflect.get,
&#125;;
const proxy = new Proxy(target, handler);
console.log(proxy.foo);
</code></pre>
<p>使用代理对原对象的访问进行修饰：</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const handler = &#123;
  get(trapTarget, property, receiver) &#123;
    let propertyDecoration = &#39;&#39;;
    if (property === &#39;foo&#39;) &#123;
      propertyDecoration = &#39;!!!&#39;;
    &#125;
    return Reflect.get(target, property, receiver) + propertyDecoration;
  &#125;,
&#125;;
const proxy = new Proxy(target, handler);
console.log(proxy.foo); // bar!!!
</code></pre>
<h2 id="可撤销代理"><a href="#可撤销代理" class="headerlink" title="可撤销代理"></a>可撤销代理</h2><p>有时候可能需要中断代理对象与目标对象之间的联系。对于使用 new Proxy()创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。Proxy 也暴露了 revocable()方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数（revoke()）是幂等的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出 TypeError。</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const handler = &#123;
  get(trapTarget, property, receiver) &#123;
    let propertyDecoration = &#39;&#39;;
    if (property === &#39;foo&#39;) &#123;
      propertyDecoration = &#39;!!!&#39;;
    &#125;
    return Reflect.get(target, property, receiver) + propertyDecoration;
  &#125;,
&#125;;
const &#123; proxy, revoke &#125; = Proxy.revocable(target, handler);
console.log(proxy.foo); // bar!!!

// 撤销代理
revoke();
console.log(proxy.foo); // TypeError: Cannot perform &#39;get&#39; on a proxy that has been revoked
</code></pre>
<h2 id="多层代理"><a href="#多层代理" class="headerlink" title="多层代理"></a>多层代理</h2><p>代理可以拦截反射 API 的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网。</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const firstProxy = new Proxy(target, &#123;
  get() &#123;
    console.log(&#39;first proxy&#39;);
    return Reflect.get(...arguments);
  &#125;,
&#125;);
const secondProxy = new Proxy(firstProxy, &#123;
  get() &#123;
    console.log(&#39;second proxy&#39;);
    return Reflect.get(...arguments);
  &#125;,
&#125;);
console.log(secondProxy.foo);
// second proxy
// first proxy
// bar
</code></pre>
<h2 id="代理捕获器与反射方法"><a href="#代理捕获器与反射方法" class="headerlink" title="代理捕获器与反射方法"></a>代理捕获器与反射方法</h2><p>代理可以捕获 13 种不同的基本操作。这些操作有各自不同的反射 API 方法、参数、关联 ECMAScript 操作和不变式。</p>
<ul>
<li>get()</li>
<li>set()</li>
<li>has()</li>
<li>defineProperty()</li>
<li>getOwnPropertyDescriptor()</li>
<li>deleteProperty()</li>
<li>ownKeys()</li>
<li>getPrototypeOf()</li>
<li>setPrototypeOf()</li>
<li>isExtensible()</li>
<li>preventExtensions()</li>
<li>apply()</li>
<li>construct()</li>
</ul>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>使用代理可以在代码中实现一些有用的编程模式。</p>
<h2 id="1-跟踪属性访问"><a href="#1-跟踪属性访问" class="headerlink" title="1. 跟踪属性访问"></a>1. 跟踪属性访问</h2><p>通过捕获 get、set 和 has 等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过。</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const proxy = new Proxy(target, &#123;
  get(target, propertyKey, receiver) &#123;
    console.log(`getting property: $&#123;propertyKey&#125;`);
    return Reflect.get(...arguments);
  &#125;,
  set(target, propertyKey, value, receiver) &#123;
    console.log(`setting property: $&#123;propertyKey&#125;, with value: $&#123;value&#125;`);
    return Reflect.set(...arguments);
  &#125;,
&#125;);
proxy.foo; // getting property: foo
proxy.foo = &#39;hello&#39;; // setting property: foo, with value: hello
</code></pre>
<h2 id="2-隐藏属性"><a href="#2-隐藏属性" class="headerlink" title="2. 隐藏属性"></a>2. 隐藏属性</h2><p>实现很简单，如果不想对外提供某个属性的访问，只需要在 get 捕获器返回 undefined 即可。</p>
<h2 id="3-属性验证"><a href="#3-属性验证" class="headerlink" title="3. 属性验证"></a>3. 属性验证</h2><p>所有赋值操作都会触发 set() 捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值。</p>
<h2 id="4-函数与构造函数参数验证"><a href="#4-函数与构造函数参数验证" class="headerlink" title="4. 函数与构造函数参数验证"></a>4. 函数与构造函数参数验证</h2><p>跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。</p>
<p>使用 apply 捕获器代理函数，执行参数检查：</p>
<pre><code>function sum(...nums) &#123;
  return nums.reduce((a, b) =&gt; a + b, 0);
&#125;

const sumProxy = new Proxy(sum, &#123;
  apply(target, thisArg, argumentsList) &#123;
    for (let item of argumentsList) &#123;
      if (typeof item !== &#39;number&#39;) &#123;
        throw new Error(&#39;arguments must be numbers&#39;);
      &#125;
    &#125;
    return Reflect.apply(...arguments);
  &#125;,
&#125;);

console.log(sumProxy(1, 2, 3, 4)); // 10
console.log(sumProxy(1, 2, 3, 4, &#39;hello&#39;)); // Error: arguments must be numbers
</code></pre>
<p>使用 contruct 捕获器代理类，检查构造器参数：</p>
<pre><code>class Person &#123;
  constructor(name) &#123;
    this.name = name;
  &#125;
&#125;

const PersonProxy = new Proxy(Person, &#123;
  construct(target, argumentsList, newTarget) &#123;
    if (argumentsList[0] === undefined) &#123;
      throw new Error(&#39;Person cannot be inited with `name` arg&#39;);
    &#125; else &#123;
      return Reflect.construct(...arguments);
    &#125;
  &#125;,
&#125;);

new PersonProxy(&#39;john&#39;); // ok
new PersonProxy(); // Error: Person cannot be inited with `name` arg
</code></pre>
<h2 id="5-数据绑定与可观察对象"><a href="#5-数据绑定与可观察对象" class="headerlink" title="5. 数据绑定与可观察对象"></a>5. 数据绑定与可观察对象</h2><p>通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作。比如，可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合中。</p>
<pre><code>const people = [];

class Person &#123;
  constructor(name) &#123;
    this.name = name;
  &#125;
&#125;

const PersonProxy = new Proxy(Person, &#123;
  construct() &#123;
    const newTarget = Reflect.construct(...arguments);
    people.push(newTarget);
    return newTarget;
  &#125;,
&#125;);

new PersonProxy(&#39;john&#39;);
new PersonProxy(&#39;jack&#39;);

console.log(people); // [ Person &#123; name: &#39;john&#39; &#125;, Person &#123; name: &#39;jack&#39; &#125; ]
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>代理是 ECMAScript 6 新增的令人兴奋和动态十足的新特性。尽管不支持向后兼容，但它开辟出了一片前所未有的 JavaScript 元编程及抽象的新天地。</p>
<p>从宏观上看，代理是真实 JavaScript 对象的透明抽象层。代理可以定义包含捕获器的处理程序对象，而这些捕获器可以拦截绝大部分 JavaScript 的基本操作和方法。在这个捕获器处理程序中，可以修改任何基本操作的行为，当然前提是遵从捕获器不变式。</p>
<p>与代理如影随形的反射 API，则封装了一整套与捕获器拦截的操作相对应的方法。可以把反射 API 看作一套基本操作，这些操作是绝大部分 JavaScript 对象 API 的基础。</p>
<p>代理的应用场景是不可限量的。开发者使用它可以创建出各种编码模式，比如（但远远不限于）跟踪属性访问、隐藏属性、阻止修改或删除属性、函数参数验证、构造函数参数验证、数据绑定，以及可观察对象。</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>代理</tag>
        <tag>Proxy</tag>
        <tag>反射</tag>
        <tag>Reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript中的垃圾回收</title>
    <url>/2021/06/25/javascript/javascript%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<p>在浏览器的发展史上，用到过两种主要的标记策略：标记清理和引用计数。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<h2 id="标记清理"><a href="#标记清理" class="headerlink" title="标记清理"></a>标记清理</h2><p>JavaScript 最常用的垃圾回收策略是标记清理（mark-and-sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。</p>
<p>给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。<br>垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。</p>
<p>到了 2008 年，IE、Firefox、Opera、Chrome 和 Safari 都在自己的 JavaScript 实现中采用标记清理（或其变体），只是在运行垃圾回收的频率上有所差异。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>另一种没那么常用的垃圾回收策略是引用计数（reference counting）。其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。<br>如果同一个值又被赋给另一个变量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。<br>垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存。<br>引用计数最早由 Netscape Navigator 3.0 采用，但很快就遇到了严重的问题：循环引用。所谓循环引用，就是对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A。<br>为避免类似的循环引用问题，应该在确保不使用的情况下切断原生 JavaScript 对象与 DOM 元素之间的连接。</p>
<p>比如，通过以下代码可以清除前面的例子中建立的循环引用：</p>
<pre><code>myObject.element = null;￼
element.someObject = null;
</code></pre>
<p>把变量设置为 null 实际上会切断变量与其之前引用值之间的关系。当下次垃圾回收程序运行时，这些值就会被删除，内存也会被回收。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>写得不好的 JavaScript 可能出现难以察觉且有害的内存泄漏问题。在内存有限的设备上，或者在函数会被调用很多次的情况下，内存泄漏可能是个大问题。JavaScript 中的内存泄漏大部分是由不合理的引用导致的。</p>
<ol>
<li>意外声明全局变量是最常见但也最容易修复的内存泄漏问题。</li>
<li>定时器也可能会悄悄地导致内存泄漏。下面的代码中，定时器的回调通过闭包引用了外部变量：</li>
</ol>
<pre><code>let name = &#39;Jake&#39;;￼
setInterval(() =&gt; &#123;￼ console.log(name);￼ &#125;, 100);
</code></pre>
<p>只要定时器一直运行，回调函数中引用的 name 就会一直占用内存。</p>
<ol start="3">
<li>使用 JavaScript 闭包很容易在不知不觉间造成内存泄漏。请看下面的例子：</li>
</ol>
<pre><code>let outer = function() &#123;￼
    let name = &#39;Jake&#39;;￼
    return function() &#123;￼
        return name;
￼ &#125;;￼
&#125;;
</code></pre>
<p>调用 outer()会导致分配给 name 的内存被泄漏。以上代码执行后创建了一个内部闭包，只要返回的函数存在就不能清理 name，因为闭包一直在引用着它。假如 name 的内容很大（不止是一个小字符串），那可能就是个大问题了。</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript面向对象</title>
    <url>/2021/06/27/javascript/javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>本文介绍了 javascript 中创建对象的方法以及实现继承的方法。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<h1 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h1><p>在 ES6 中类的概念出现之前，主要有以下创建对象的方法。注，ES6 的类都仅仅是封装了 ES5.1 构造函数加原型继承的语法糖而已。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是一种众所周知的设计模式，广泛应用于软件工程领域，用于抽象创建特定对象的过程。</p>
<pre><code>function createPerson(name, age, job) &#123;
  let o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function () &#123;
    console.log(this.name);
  &#125;;
  return o;
&#125;
let person1 = createPerson(&#39;Nicholas&#39;, 29, &#39;Software Engineer&#39;);
let person2 = createPerson(&#39;Greg&#39;, 27, &#39;Doctor&#39;);
</code></pre>
<h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><pre><code>function Person(name, age, job) &#123;
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function () &#123;
    console.log(this.name);
  &#125;;
&#125;
let person1 = new Person(&#39;Nicholas&#39;, 29, &#39;Software Engineer&#39;);
let person2 = new Person(&#39;Greg&#39;, 27, &#39;Doctor&#39;);
person1.sayName(); // Nicholas￼
person2.sayName(); // Greg
</code></pre>
<p>执行 new 操作符时，引擎内部会执行如下操作：</p>
<ul>
<li>在内存中创建一个新对象。</li>
<li>这个新对象内部的[[Prototype]]特性被赋值为构造函数的 prototype 属性。</li>
<li>构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。</li>
<li>执行构造函数内部的代码（给新对象添加属性）。</li>
<li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</li>
</ul>
<p>构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。因此对前面的例子而言，person1 和 person2 都有名为 sayName()的方法，但这两个方法不是同一个 Function 实例。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型。</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>ECMA-262 把原型链定义为 ECMAScript 的主要继承方式。其基本思想就是通过原型继承多个引用类型的属性和方法。</p>
<p>重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。</p>
<p>原型链虽然是实现继承的强大工具，但它也有问题。主要问题出现在原型中包含引用值的时候。前面在谈到原型的问题时也提到过，原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。</p>
<p>原型链的第二个问题是，子类型在实例化时不能给父类型的构造函数传参。事实上，我们无法在不影响所有对象实例的情况下把参数传进父类的构造函数。再加上之前提到的原型中包含引用值的问题，就导致原型链基本不会被单独使用。</p>
<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>为了解决原型包含引用值导致的继承问题，一种叫作“盗用构造函数”（constructor stealing）的技术在开发社区流行起来（这种技术有时也称作“对象伪装”或“经典继承”）。基本思路很简单：在子类构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用 apply()和 call()方法以新创建的对象为上下文执行构造函数。</p>
<ol>
<li>传递参数</li>
</ol>
<p>相比于使用原型链，盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参。</p>
<pre><code>function SuperType(name) &#123;
  this.name = name;
&#125;

function SubType() &#123;
  // 继承SuperType并传参￼
  SuperType.call(this, &#39;Nicholas&#39;);
  // 实例属性￼
  this.age = 29;
&#125;

let instance = new SubType();
console.log(instance.name); // &quot;Nicholas&quot;;
console.log(instance.age); // 29
</code></pre>
<ol start="2">
<li>盗用构造函数的问题</li>
</ol>
<p>盗用构造函数的主要缺点，也是使用构造函数模式自定义类型的问题：必须在构造函数中定义方法，因此函数不能重用。此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。由于存在这些问题，盗用构造函数基本上也不能单独使用。</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。</p>
<p>组合继承弥补了原型链和盗用构造函数的不足，是 JavaScript 中使用最多的继承模式。而且组合继承也保留了 instanceof 操作符和 isPrototypeOf()方法识别合成对象的能力。</p>
<pre><code>function SuperType(name) &#123;
  this.name = name;
  this.colors = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];
&#125;
SuperType.prototype.sayName = function () &#123;
  console.log(this.name);
&#125;;
function SubType(name, age) &#123;
  SuperType.call(this, name); //第二次调用SuperType()
  this.age = age;
&#125;
SubType.prototype = new SuperType(); //第一次调用SuperType()
SubType.prototype.constructor = SubType;
SubType.prototype.sayAge = function () &#123;
  console.log(this.age);
&#125;;
</code></pre>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>JavaScript 的继承主要通过原型链来实现。原型链涉及把构造函数的原型赋值为另一个类型的实例。这样一来，子类就可以访问父类的所有属性和方法，就像基于类的继承那样。原型链的问题是所有继承的属性和方法都会在对象实例间共享，无法做到实例私有。</p>
<p>盗用构造函数模式通过在子类构造函数中调用父类构造函数，可以避免这个问题。这样可以让每个实例继承的属性都是私有的，但要求类型只能通过构造函数模式来定义（因为子类不能访问父类原型上的方法）。</p>
<p>目前最流行的继承模式是组合继承，即通过原型链继承共享的属性和方法，通过盗用构造函数继承实例属性。</p>
<h2 id="其他继承方式"><a href="#其他继承方式" class="headerlink" title="其他继承方式"></a>其他继承方式</h2><p>除上述模式之外，还有以下几种继承模式。<br>❑ 原型式继承可以无须明确定义构造函数而实现继承，本质上是对给定对象执行浅复制。这种操作的结果之后还可以再进一步增强。<br>❑ 与原型式继承紧密相关的是寄生式继承，即先基于一个对象创建一个新对象，然后再增强这个新对象，最后返回新对象。这个模式也被用在组合继承中，用于避免重复调用父类构造函数导致的浪费。<br>❑ 寄生组合继承被认为是实现基于类型继承的最有效方式。</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>2006 年，Douglas Crockford 写了一篇文章：《JavaScript 中的原型式继承》（“Prototypal Inheritance in JavaScript”）。这篇文章介绍了一种不涉及严格意义上构造函数的继承方法。他的出发点是即使不自定义类型也可以通过原型实现对象之间的信息共享。文章最终给出了一个函数：</p>
<pre><code>function object(o) &#123;
  function F() &#123;&#125;
  F.prototype = o;
  return new F();
&#125;
</code></pre>
<p>Crockford 推荐的原型式继承适用于这种情况：你有一个对象，想在它的基础上再创建一个新对象。你需要把这个对象先传给 object()，然后再对返回的对象进行适当修改。</p>
<p>ECMAScript 5 通过增加 Object.create()方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>与原型式继承比较接近的一种继承方式是寄生式继承（parasitic inheritance），也是 Crockford 首倡的一种模式。寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。</p>
<pre><code>function createAnother(original) &#123;
  let clone = object(original); // 通过调用函数创建一个新对象
  clone.sayHi = function () &#123;
    // 以某种方式增强这个对象￼
    console.log(&#39;hi&#39;);
  &#125;;
  return clone; // 返回这个对象
&#125;
</code></pre>
<p>寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景。object()函数不是寄生式继承所必需的，任何返回新对象的函数都可以在这里使用。注意: 通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。</p>
<h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><p>组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在子类构造函数中调用。本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。</p>
<h1 id="ES6-Class"><a href="#ES6-Class" class="headerlink" title="ES6 Class"></a>ES6 Class</h1><p>抽象基类<br>有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。虽然 ECMAScript 没有专门支持这种类的语法，但通过 new.target 也很容易实现。</p>
<p>new.target 保存通过 new 关键字调用的类或函数。通过在实例化时检测 new.target 是不是抽象基类，可以阻止对抽象基类的实例化：</p>
<pre><code>// 使用 new.target 实现 ES6 抽象基类
class Vehicle &#123;
  constructor() &#123;
    console.log(new.target);
    if (new.target === Vehicle) &#123;
      throw new Error(&#39;Vehicle cannot be directly instantiated&#39;);
    &#125;
  &#125;
&#125;

new Vehicle(); // Error: Vehicle cannot be directly instantiated
</code></pre>
<p>另外，通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法。因为原型方法在调用类构造函数之前就已经存在了，所以可以通过 this 关键字来检查相应的方法：</p>
<pre><code>// 抽象基类
class Vehicle &#123;
  constructor() &#123;
    if (new.target === Vehicle) &#123;
      throw new Error(&#39;Vehicle cannot be directly instantiated&#39;);
    &#125;

    if (!this.foo) &#123;
      throw new Error(&#39;Inheriting class must define foo()&#39;);
    &#125;
    console.log(&#39;success! &#39;);
  &#125;
&#125;

// 派生类
class Bus extends Vehicle &#123;
  foo() &#123;&#125;
&#125;

// 派生类
class Van extends Vehicle &#123;&#125;

new Bus(); // success!
new Van(); // Error: Inheriting class must define foo()
</code></pre>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>面向对象</tag>
        <tag>原型继承</tag>
      </tags>
  </entry>
  <entry>
    <title>前端好文</title>
    <url>/2021/06/29/web%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%A5%BD%E6%96%87/</url>
    <content><![CDATA[<p>日常收集的关于前端开发的优秀文章，多读多消化。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API">web API 接口参考</a></p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events">web 事件参考</a></p>
</li>
<li><p><a href="https://iwiki.woa.com/pages/viewpage.action?pageId=375828171">前端监控实现原理</a></p>
</li>
<li><p><a href="http://km.oa.com/group/sitepoint/articles/show/364557">前端监控实现思路</a></p>
</li>
<li><p><a href="http://km.oa.com/group/32560/articles/show/365524">emonitor 前端监控实现</a></p>
</li>
<li><p><a href="https://www.wxapp-union.com/article-6184-1.html">小程序监控</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6844903617292402702">小程序异常监控收集</a></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html">JavaScript Source Map 详解</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/1TQwNx0Q69qEBcoXwJ-Vpg">来看看字节是如何做前端异常监控的，source 简介</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/rJ0yMBcDvm9KD0OF2gLfAA">从微服务到微前端：浅谈微前端的设计思想</a></p>
</li>
<li><p><a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/">useEffect 完整指南</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/JURLrg4VCBDCN3vttV4ahQ">react hooks 原理</a></p>
</li>
<li><p>精读《React Hooks》</p>
</li>
<li><p>精读《怎么用 React Hooks 造轮子》</p>
</li>
<li><p>精读《useEffect 完全指南》</p>
</li>
<li><p>精读《Function VS Class 组件》</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/-dVGGoVA8kpv9PaSNMoMSg">React 性能优化完全指南</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/UPy5Qwesz8ia3XpjrUJ4oQ">深入理解 React Router：Context、Hooks、Refs、Memo 特性讲解</a></p>
</li>
<li><p><a href="https://github.com/linqinghao/blog/issues/18">Typescript 中的装饰器与元数据反射</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/PFgc8xD7gT40-9qXNTpk7A">Typescript 装饰器详解</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000021508564">使用 typescript 装饰器构建 nodejs 路由</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/215385588">使用 typescript 装饰器构建 nodejs 路由</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/QcVA6yEw3NvDV1ZLtoMcug">手写一个脚手架</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000020335010?utm_source=sf-similar-article">手把手教你搭建脚手架工具</a></p>
</li>
<li><p><a href="http://www.semlinker.com/categories/node-js/">深入学习 nodejs 系列</a></p>
</li>
<li><p><a href="https://yjhjstz.gitbooks.io/deep-into-node/content/">deep-into-node</a></p>
</li>
<li><p><a href="https://jishuin.proginn.com/p/763bfbd57afc">虚拟列表实现原理</a></p>
</li>
<li><p><a href="https://jishuin.proginn.com/u/548404">这个用户下有些文章质量挺高</a></p>
</li>
<li><p><a href="https://jishuin.proginn.com/p/763bfbd4cedb">学会 Proxy 真的可以为所欲为</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端好文</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>优秀文章</tag>
      </tags>
  </entry>
  <entry>
    <title>前端监控思路和实现</title>
    <url>/2021/07/05/web%E5%89%8D%E7%AB%AF/%E7%AB%AF%E7%9B%91%E6%8E%A7%E6%80%9D%E8%B7%AF%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>前端监控主要包括信息的采集、上报和告警。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<h2 id="前端需要监控什么内容"><a href="#前端需要监控什么内容" class="headerlink" title="前端需要监控什么内容"></a>前端需要监控什么内容</h2><ol>
<li>错误监控<ul>
<li>1.1 js 执行错误</li>
<li>1.2 ajax 错误</li>
<li>1.3 promise 错误</li>
<li>1.4 静态资源加载错误</li>
<li>1.5 本地输入的 console 日志</li>
</ul>
</li>
<li>CGI 测速（响应码、响应耗时）</li>
<li>静态资源质量（耗时）</li>
<li>页面质量（首屏耗时）</li>
<li>平台或网络信息</li>
</ol>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="错误监控"><a href="#错误监控" class="headerlink" title="错误监控"></a>错误监控</h3><ol>
<li>js 脚本执行错误时会触发页面的 onerror 事件，通过该事件可以捕获到脚本执行错误。</li>
</ol>
<pre><code>window.onerror = function(message, source, lineno, colno, error) &#123;
    // message: 错误信息
    // source: 发生错误的脚本URL
    // lineno: 发生错误的行号
    // colno: 发生错误的列号
    // error： 错误对象
&#125;
</code></pre>
<ol start="2">
<li>静态资源加载错误时，会被 <code>window.addEventListener(&#39;error&#39;, func, true)</code>(注意第三个参数) 捕获。</li>
</ol>
<pre><code>// 捕获静态资源加载错误
// 注意第三个参数为true，表示要在事件捕获阶段处理
window.addEventListener(&#39;error&#39;, function(e)&#123;
    // 上报错误
&#125;, true);
</code></pre>
<ol start="3">
<li>promise 异常会触发页面的 unhandledrejection 事件，可以通过该事件捕获异常。</li>
</ol>
<pre><code>window.addEventListener(&#39;unhandledrejection&#39;, function(err) &#123;
    // 上报错误
&#125;, true);
</code></pre>
<ol start="4">
<li>CGI 监控</li>
</ol>
<p>CGI 监控的方式有两种，一种是业务方接口调用失败时，主动上报；另一种是改写 ajax 和 fetch 方法来实现上报。第二种方法对业务无侵入，比较灵活，但是上报信息可能不如第一种详细。</p>
<pre><code>//改写 fetch
function overrideFetch() &#123;
  ...
  const originFetch = window.fetch;
  window.fetch = (url, option) =&gt; &#123;
    return originFetch(url, option)
    .then(res =&gt; &#123;
      // 在这里拦截到接口请求情况进行上报处理
      ...
    &#125;)
  &#125;
&#125;

// 改写XHR
const xhrProto = window.XMLHttpRequest.prototype,
    originSend = xhrProto.send;
    xhrProto.send = function aegisFakeXhrSend() &#123;
    // 在这里获取请求情况进行上报处理
    ...
    return originSend.apply(this, arguments)
&#125;
</code></pre>
<ol start="5">
<li>console 日志监控</li>
</ol>
<p>前端代码中经常会使用 console 来打印日志，其中 console.error 中抛出的信息可能对我们有用。可以通过改写底层的 console.error 方法来上报数据。</p>
<pre><code>if (typeof console !== &#39;undefined&#39; &amp;&amp; typeof console.error === &#39;function&#39;) &#123;
    const nativeConsoleError = console.error;
    console.error = (...rest) =&gt; &#123;
    nativeConsoleError.apply(window.console, rest);
    // 发送错误信息到服务器
    &#125;;
&#125;
</code></pre>
<h3 id="静态资源质量"><a href="#静态资源质量" class="headerlink" title="静态资源质量"></a>静态资源质量</h3><p>前端静态资源主要包括 img、css、script、link、audio、video 这几大块内容。可以通过 performance API 来收集所有静态资源的请求情况，然后利用 performance.timing 获取每个时间节点来计算静态资源的加载情况。</p>
<pre><code>function collect() &#123;
    const entries = performance.getEntriesByType(&#39;resource&#39;);

    for (let i = 0, l = entries.length; i &lt; l; i++) &#123;
        const entry = entries[i] as StaticPerformanceResourceTiming;
        if ([&#39;link&#39;, &#39;img&#39;, &#39;script&#39;].includes(entry.initiatorType)) &#123;
            // dns解析时间
            const DNSResolveTime = entry.domainLookupEnd - entry.domainLookupStart;
            // 响应总时间
            const respTime = entry.responseEnd - entry.startTime;
            // 其他时间，参考 performance API

            const resourceName = entry.name;
            // 上报
            report(&#123; event: &#39;static-resource&#39;, name: resourceName, data: &#123; DNSResolveTime, respTime&#125; &#125;);
        &#125;
    &#125;
&#125;

// 可以开启定时器，定时收集上报
setInterval(collect, this.config.collectInterval);
</code></pre>
<h3 id="CGI-测速"><a href="#CGI-测速" class="headerlink" title="CGI 测速"></a>CGI 测速</h3><p>同样的，通过改写 ajax 和 fetch，可以获取请求和响应的时间点，从而计算得出 CGI 的请求耗时。</p>
<h3 id="页面质量"><a href="#页面质量" class="headerlink" title="页面质量"></a>页面质量</h3><p>在页面性能中，最重要的是计算<code>首屏渲染时间</code>。</p>
<p>由于 React 、Vue 等框架的出现，DOMContentLoaded 事件已经失去了原本的作用，现在 “首屏渲染时间” 的计算大多数时候是依靠人工打点，这样会侵入业务，使用不便。下面介绍一套新的算法，尽可能准确的对 “首屏渲染时间” 进行估算，主要运用到了 MutationObserver、performance。</p>
<p>MutationObserver 提供了监听页面 DOM 树变化的能力：</p>
<pre><code>// 注册监听函数
const observer = new MutationObserver((mutations) =&gt; &#123;
    // 获取增加的节点
    for(let i = 0; i &lt; mutations.length; i++) &#123;
        console.log(mutations[0].addedNodes);
    &#125;
&#125;);

// 监听 document 的节点变化
observer.observe(document, &#123;
    childList: true,
    subtree: true
&#125;);
</code></pre>
<p><code>performance</code> API 能计算资源加载的时间（详见上文静态资源收集）</p>
<p>通过 MutationObserver 观察页面 dom 树的变化，只关心 nodeType === 1 的元素，且剔除 script、style 等不会在页面中展示出来的元素节点，最后比较找出<code>首屏节点完成耗时最大的一个</code>作为 firstScreenTiming 首屏渲染时间。</p>
<p>但这个 firstScreenTiming 首屏渲染时间还不是最终确认得到的最大渲染时间，我们都知道页面的“加载完整”除了节点元素加载完毕外，首屏中的图片加载完成也是一个判断标准。得益于浏览器提供的 performance API ，这个计算过程非常简单高效。</p>
<pre><code>window.performance.getEntriesByType(&#39;resource&#39;).forEach((resource: any) =&gt; &#123;
    if (
        resource.initiatorType === &#39;img&#39; &amp;&amp;
        resource.responseEnd &gt; maxTime
    )&#123;
        //遍历找出图片资源加载中耗时最大的一个
        //并与 DOM 节点加载得到的‘首屏渲染时间’比较，取最大的值作为真正的 firstScreenTiming
    &#125;
&#125;);
</code></pre>
<h3 id="平台或网络信息"><a href="#平台或网络信息" class="headerlink" title="平台或网络信息"></a>平台或网络信息</h3><p>平台设备信息可以通过 UserAgent 解析而来。</p>
<p>网络信息可以通过 navigator.connection API 获取到。</p>
<pre><code>const result = navigator.connection;
result.effectiveType; // 2g, 3g, 4g, 5g, wifi ... 注意，该结果是浏览器根据当前网速的测算值，不一定准确
result.downlink;      // 网络下行速度，单位为 Mbits/s
result.rtt;           // 估算的往返时间
result.obChange = function()&#123;&#125;;  // 网络变更时触发
</code></pre>
<h2 id="离线日志"><a href="#离线日志" class="headerlink" title="离线日志"></a>离线日志</h2><p>可以考虑使用 IndexedDB 在用户本地存储离线日志，这样就算因为用户网络不佳，无法进行通信，日志也会被记录下来，在后续合适的时机进行上报。</p>
<h2 id="数据上报和告警"><a href="#数据上报和告警" class="headerlink" title="数据上报和告警"></a>数据上报和告警</h2><p>可以使用 ElasticSearch 来存储日志，配合 Kibana 查询展示。</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>前端监控</tag>
      </tags>
  </entry>
  <entry>
    <title>江雪</title>
    <url>/2021/06/28/%E8%AF%97%E8%AF%8D/%E6%B1%9F%E9%9B%AA/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>诗词</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>柳宗元</tag>
      </tags>
  </entry>
  <entry>
    <title>遇见春天遇见你</title>
    <url>/2021/06/22/%E8%AF%97%E8%AF%8D/%E9%81%87%E8%A7%81%E6%98%A5%E5%A4%A9%E9%81%87%E8%A7%81%E4%BD%A0/</url>
    <content><![CDATA[<p>沾衣欲湿杏花雨，春风十里不如你。</p>
<p>东晋永和年间，一个叫祝英台的姑娘，女扮男装，在一个明媚的春天，走出家门，去杭城求学，在春天的路上，他碰到了一个叫梁山伯的小伙子，他们草桥结拜，开始了一段化蝶的传说。一千多年来，你依旧可以在花海树影中，看到他们双宿双飞，为爱徘徊。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<p>东晋咸安年间，正当壮年的王献之走出家门，在桃花汛到来的时节，来到金陵的河边，在一个渡口，碰到一个叫桃叶的姑娘，从此金风玉露一相逢，便胜却人间无数。后来这个渡口也因为他们的相遇，从此被叫做桃叶渡。</p>
<p>大唐贞元十一年，落榜的考生崔护，在百无聊赖中去郊外春游，只是因为口渴讨水，便遇到一个叫绛娘的姑娘。第二年，他念念不忘，又有回想，又在春天重游故地，在绛娘家的门上，留下一首绝句。去年今日此门中，人面桃花相映红，人面不知何处去，桃花依旧笑春风。绛娘因此死，绛娘因此生，崔护也因此名传千古。</p>
<p>大唐元和四年，三十岁的袁震任监察御史，出使西蜀，当时正值春天，意气风发的袁震来到西川，和才女薛涛在那个山花烂漫的春天里，开始了一段惊天动地的姐弟恋。</p>
<p>事实上，春天的故事远不止这些。</p>
<p>墙头马上里的李千金，只因为是春天，忍不住站在墙边的软梯上，探头向外一望，就望见了那个比裴勇俊还要帅上几分的裴少俊。据说，唐伯虎也是在春游灵隐寺的时候，初见秋香，惊为天人。浮生六记里的沈复和芸娘，他们的春游更成为那个时代的经典。至于白娘子之遇许仙，完全是因为一千七百年前的一个小牧童，在春天放牧的时候，救了一小白蛇，然后才有了一千七百年后的西湖边的春天，他们断桥的遇见。</p>
<p>所以美丽的春天，不适合做宅女，不适合做宅男。</p>
<p>春天万物生发，生机盎然，适合走出门去，在生命最好的时候，让上苍恩赐一场遇见。</p>
<p>春风十里不如你啊，从一个日子走向另外一个日子，从一个春天走向另外一个春天，从一个自己走向另外一个自己。</p>
<p>跋涉的时候，遇见风，遇见雨，遇见他们，遇见星辰。</p>
<p>驻足的时候，遇见来，遇见去，遇见欢喜。</p>
<p>人生就是在路上，路上最大的幸福，就是遇见春天，遇见你。</p>
]]></content>
      <categories>
        <category>诗词</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>春天</tag>
      </tags>
  </entry>
</search>
