<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>javascript中的垃圾回收</title>
    <url>/2021/06/25/javascript/javascript%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<p>在浏览器的发展史上，用到过两种主要的标记策略：标记清理和引用计数。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<h2 id="标记清理"><a href="#标记清理" class="headerlink" title="标记清理"></a>标记清理</h2><p>JavaScript 最常用的垃圾回收策略是标记清理（mark-and-sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。</p>
<p>给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。<br>垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。</p>
<p>到了 2008 年，IE、Firefox、Opera、Chrome 和 Safari 都在自己的 JavaScript 实现中采用标记清理（或其变体），只是在运行垃圾回收的频率上有所差异。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>另一种没那么常用的垃圾回收策略是引用计数（reference counting）。其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。<br>如果同一个值又被赋给另一个变量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。<br>垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存。<br>引用计数最早由 Netscape Navigator 3.0 采用，但很快就遇到了严重的问题：循环引用。所谓循环引用，就是对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A。<br>为避免类似的循环引用问题，应该在确保不使用的情况下切断原生 JavaScript 对象与 DOM 元素之间的连接。</p>
<p>比如，通过以下代码可以清除前面的例子中建立的循环引用：</p>
<pre><code>myObject.element = null;￼
element.someObject = null;
</code></pre>
<p>把变量设置为 null 实际上会切断变量与其之前引用值之间的关系。当下次垃圾回收程序运行时，这些值就会被删除，内存也会被回收。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>写得不好的 JavaScript 可能出现难以察觉且有害的内存泄漏问题。在内存有限的设备上，或者在函数会被调用很多次的情况下，内存泄漏可能是个大问题。JavaScript 中的内存泄漏大部分是由不合理的引用导致的。</p>
<ol>
<li>意外声明全局变量是最常见但也最容易修复的内存泄漏问题。</li>
<li>定时器也可能会悄悄地导致内存泄漏。下面的代码中，定时器的回调通过闭包引用了外部变量：</li>
</ol>
<pre><code>let name = &#39;Jake&#39;;￼
setInterval(() =&gt; &#123;￼ console.log(name);￼ &#125;, 100);
</code></pre>
<p>只要定时器一直运行，回调函数中引用的 name 就会一直占用内存。</p>
<ol start="3">
<li>使用 JavaScript 闭包很容易在不知不觉间造成内存泄漏。请看下面的例子：</li>
</ol>
<pre><code>let outer = function() &#123;￼
    let name = &#39;Jake&#39;;￼
    return function() &#123;￼
        return name;
￼ &#125;;￼
&#125;;
</code></pre>
<p>调用 outer()会导致分配给 name 的内存被泄漏。以上代码执行后创建了一个内部闭包，只要返回的函数存在就不能清理 name，因为闭包一直在引用着它。假如 name 的内容很大（不止是一个小字符串），那可能就是个大问题了。</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>前端好文</title>
    <url>/2021/06/29/web%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%A5%BD%E6%96%87/</url>
    <content><![CDATA[<p>日常收集的关于前端开发的优秀文章，多读多消化。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API">web API 接口参考</a></p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events">web 事件参考</a></p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference">javascript 参考 MDN</a></p>
</li>
<li><p><a href="https://iwiki.woa.com/pages/viewpage.action?pageId=375828171">前端监控实现原理</a></p>
</li>
<li><p><a href="http://km.oa.com/group/sitepoint/articles/show/364557">前端监控实现思路</a></p>
</li>
<li><p><a href="http://km.oa.com/group/32560/articles/show/365524">emonitor 前端监控实现</a></p>
</li>
<li><p><a href="https://www.wxapp-union.com/article-6184-1.html">小程序监控</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6844903617292402702">小程序异常监控收集</a></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html">JavaScript Source Map 详解</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/1TQwNx0Q69qEBcoXwJ-Vpg">来看看字节是如何做前端异常监控的，source 简介</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/rJ0yMBcDvm9KD0OF2gLfAA">从微服务到微前端：浅谈微前端的设计思想</a></p>
</li>
<li><p><a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/">useEffect 完整指南</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/JURLrg4VCBDCN3vttV4ahQ">react hooks 原理</a></p>
</li>
<li><p>精读《React Hooks》</p>
</li>
<li><p>精读《怎么用 React Hooks 造轮子》</p>
</li>
<li><p>精读《useEffect 完全指南》</p>
</li>
<li><p>精读《Function VS Class 组件》</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/-dVGGoVA8kpv9PaSNMoMSg">React 性能优化完全指南</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/UPy5Qwesz8ia3XpjrUJ4oQ">深入理解 React Router：Context、Hooks、Refs、Memo 特性讲解</a></p>
</li>
<li><p><a href="https://github.com/linqinghao/blog/issues/18">Typescript 中的装饰器与元数据反射</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/PFgc8xD7gT40-9qXNTpk7A">Typescript 装饰器详解</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000021508564">使用 typescript 装饰器构建 nodejs 路由</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/215385588">使用 typescript 装饰器构建 nodejs 路由</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/QcVA6yEw3NvDV1ZLtoMcug">手写一个脚手架</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000020335010?utm_source=sf-similar-article">手把手教你搭建脚手架工具</a></p>
</li>
<li><p><a href="http://www.semlinker.com/categories/node-js/">深入学习 nodejs 系列</a></p>
</li>
<li><p><a href="https://yjhjstz.gitbooks.io/deep-into-node/content/">deep-into-node</a></p>
</li>
<li><p><a href="https://jishuin.proginn.com/p/763bfbd57afc">虚拟列表实现原理</a></p>
</li>
<li><p><a href="https://jishuin.proginn.com/u/548404">这个用户下有些文章质量挺高</a></p>
</li>
<li><p><a href="https://jishuin.proginn.com/p/763bfbd4cedb">学会 Proxy 真的可以为所欲为</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/Etied9JkAB2jZUMvD4LWIA">腾讯课堂小程序性能极致优化</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端好文</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>优秀文章</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript中的代理与反射</title>
    <url>/2021/06/28/javascript/javascript%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>ECMAScript6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<h1 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h1><h2 id="创建代理"><a href="#创建代理" class="headerlink" title="创建代理"></a>创建代理</h2><p>代理是使用 Proxy 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。</p>
<pre><code>const target = &#123; id: &#39;target&#39; &#125;;
const handler = &#123;&#125;;

const proxy = new Proxy(target, handler);

console.log(target.id); // target
console.log(proxy.id); // target

// 给目标赋值也会反映到代理上，两者引用的是同一个对象
target.id = &#39;foo&#39;;
console.log(target.id); // foo
console.log(proxy.id); // foo

// 给代理赋值同样也会反映到目标上
proxy.id = &#39;bar&#39;;
console.log(target.id); // bar
console.log(proxy.id); // bar

console.log(target.hasOwnProperty(&#39;id&#39;)); // true
console.log(proxy.hasOwnProperty(&#39;id&#39;)); // true
</code></pre>
<h2 id="定义捕获器"><a href="#定义捕获器" class="headerlink" title="定义捕获器"></a>定义捕获器</h2><p>使用代理的主要目的是可以定义捕获器（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。</p>
<pre><code>注： 捕获器（trap）是从操作系统中借用的概念。在操作系统中，捕获器是程序流中的一个同步中断，可以暂停程序流，转而执行一段子例程，之后再返回原始程序流。
</code></pre>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const handler = &#123;
  get() &#123;
    return &#39;handler override&#39;;
  &#125;,
&#125;;
const proxy = new Proxy(target, handler);

// 注意，只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正常的行为。
console.log(proxy.foo); // handler override
console.log(target.foo); // bar
</code></pre>
<h2 id="捕获器参数和反射-API"><a href="#捕获器参数和反射-API" class="headerlink" title="捕获器参数和反射 API"></a>捕获器参数和反射 API</h2><p>所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如，get()捕获器会接收到目标对象、要查询的属性和代理对象三个参数。</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const handler = &#123;
  get(trapTarget, property, receiver) &#123;
    console.log(target === trapTarget);
    console.log(property);
    console.log(receiver === proxy);

    // 有了这些参数，就可以重建被捕获方法的原始行为
    return trapTarget[property];
  &#125;,
&#125;;
const proxy = new Proxy(target, handler);
console.log(proxy.foo);
// true
// foo
// true
// bar
</code></pre>
<p>所有捕获器都可以基于自己的参数重建原始操作，但并非所有捕获器行为都像 get()那么简单。因此，通过手动写码如法炮制的想法是不现实的。实际上，开发者并不需要手动重建原始行为，而是可以通过调用全局 Reflect 对象上（封装了原始行为）的同名方法来轻松重建。处理程序对象中所有可以捕获的方法都有对应的反射（Reflect）API 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const handler = &#123;
  get() &#123;
    return Reflect.get(...arguments);
  &#125;,
  // 甚至可以使用更简洁的写法
  // get: Reflect.get,
&#125;;
const proxy = new Proxy(target, handler);
console.log(proxy.foo);
</code></pre>
<p>使用代理对原对象的访问进行修饰：</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const handler = &#123;
  get(trapTarget, property, receiver) &#123;
    let propertyDecoration = &#39;&#39;;
    if (property === &#39;foo&#39;) &#123;
      propertyDecoration = &#39;!!!&#39;;
    &#125;
    return Reflect.get(target, property, receiver) + propertyDecoration;
  &#125;,
&#125;;
const proxy = new Proxy(target, handler);
console.log(proxy.foo); // bar!!!
</code></pre>
<h2 id="可撤销代理"><a href="#可撤销代理" class="headerlink" title="可撤销代理"></a>可撤销代理</h2><p>有时候可能需要中断代理对象与目标对象之间的联系。对于使用 new Proxy()创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。Proxy 也暴露了 revocable()方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数（revoke()）是幂等的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出 TypeError。</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const handler = &#123;
  get(trapTarget, property, receiver) &#123;
    let propertyDecoration = &#39;&#39;;
    if (property === &#39;foo&#39;) &#123;
      propertyDecoration = &#39;!!!&#39;;
    &#125;
    return Reflect.get(target, property, receiver) + propertyDecoration;
  &#125;,
&#125;;
const &#123; proxy, revoke &#125; = Proxy.revocable(target, handler);
console.log(proxy.foo); // bar!!!

// 撤销代理
revoke();
console.log(proxy.foo); // TypeError: Cannot perform &#39;get&#39; on a proxy that has been revoked
</code></pre>
<h2 id="多层代理"><a href="#多层代理" class="headerlink" title="多层代理"></a>多层代理</h2><p>代理可以拦截反射 API 的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网。</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const firstProxy = new Proxy(target, &#123;
  get() &#123;
    console.log(&#39;first proxy&#39;);
    return Reflect.get(...arguments);
  &#125;,
&#125;);
const secondProxy = new Proxy(firstProxy, &#123;
  get() &#123;
    console.log(&#39;second proxy&#39;);
    return Reflect.get(...arguments);
  &#125;,
&#125;);
console.log(secondProxy.foo);
// second proxy
// first proxy
// bar
</code></pre>
<h2 id="代理捕获器与反射方法"><a href="#代理捕获器与反射方法" class="headerlink" title="代理捕获器与反射方法"></a>代理捕获器与反射方法</h2><p>代理可以捕获 13 种不同的基本操作。这些操作有各自不同的反射 API 方法、参数、关联 ECMAScript 操作和不变式。</p>
<ul>
<li>get()</li>
<li>set()</li>
<li>has()</li>
<li>defineProperty()</li>
<li>getOwnPropertyDescriptor()</li>
<li>deleteProperty()</li>
<li>ownKeys()</li>
<li>getPrototypeOf()</li>
<li>setPrototypeOf()</li>
<li>isExtensible()</li>
<li>preventExtensions()</li>
<li>apply()</li>
<li>construct()</li>
</ul>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>使用代理可以在代码中实现一些有用的编程模式。</p>
<h2 id="1-跟踪属性访问"><a href="#1-跟踪属性访问" class="headerlink" title="1. 跟踪属性访问"></a>1. 跟踪属性访问</h2><p>通过捕获 get、set 和 has 等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过。</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const proxy = new Proxy(target, &#123;
  get(target, propertyKey, receiver) &#123;
    console.log(`getting property: $&#123;propertyKey&#125;`);
    return Reflect.get(...arguments);
  &#125;,
  set(target, propertyKey, value, receiver) &#123;
    console.log(`setting property: $&#123;propertyKey&#125;, with value: $&#123;value&#125;`);
    return Reflect.set(...arguments);
  &#125;,
&#125;);
proxy.foo; // getting property: foo
proxy.foo = &#39;hello&#39;; // setting property: foo, with value: hello
</code></pre>
<h2 id="2-隐藏属性"><a href="#2-隐藏属性" class="headerlink" title="2. 隐藏属性"></a>2. 隐藏属性</h2><p>实现很简单，如果不想对外提供某个属性的访问，只需要在 get 捕获器返回 undefined 即可。</p>
<h2 id="3-属性验证"><a href="#3-属性验证" class="headerlink" title="3. 属性验证"></a>3. 属性验证</h2><p>所有赋值操作都会触发 set() 捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值。</p>
<h2 id="4-函数与构造函数参数验证"><a href="#4-函数与构造函数参数验证" class="headerlink" title="4. 函数与构造函数参数验证"></a>4. 函数与构造函数参数验证</h2><p>跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。</p>
<p>使用 apply 捕获器代理函数，执行参数检查：</p>
<pre><code>function sum(...nums) &#123;
  return nums.reduce((a, b) =&gt; a + b, 0);
&#125;

const sumProxy = new Proxy(sum, &#123;
  apply(target, thisArg, argumentsList) &#123;
    for (let item of argumentsList) &#123;
      if (typeof item !== &#39;number&#39;) &#123;
        throw new Error(&#39;arguments must be numbers&#39;);
      &#125;
    &#125;
    return Reflect.apply(...arguments);
  &#125;,
&#125;);

console.log(sumProxy(1, 2, 3, 4)); // 10
console.log(sumProxy(1, 2, 3, 4, &#39;hello&#39;)); // Error: arguments must be numbers
</code></pre>
<p>使用 contruct 捕获器代理类，检查构造器参数：</p>
<pre><code>class Person &#123;
  constructor(name) &#123;
    this.name = name;
  &#125;
&#125;

const PersonProxy = new Proxy(Person, &#123;
  construct(target, argumentsList, newTarget) &#123;
    if (argumentsList[0] === undefined) &#123;
      throw new Error(&#39;Person cannot be inited with `name` arg&#39;);
    &#125; else &#123;
      return Reflect.construct(...arguments);
    &#125;
  &#125;,
&#125;);

new PersonProxy(&#39;john&#39;); // ok
new PersonProxy(); // Error: Person cannot be inited with `name` arg
</code></pre>
<h2 id="5-数据绑定与可观察对象"><a href="#5-数据绑定与可观察对象" class="headerlink" title="5. 数据绑定与可观察对象"></a>5. 数据绑定与可观察对象</h2><p>通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作。比如，可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合中。</p>
<pre><code>const people = [];

class Person &#123;
  constructor(name) &#123;
    this.name = name;
  &#125;
&#125;

const PersonProxy = new Proxy(Person, &#123;
  construct() &#123;
    const newTarget = Reflect.construct(...arguments);
    people.push(newTarget);
    return newTarget;
  &#125;,
&#125;);

new PersonProxy(&#39;john&#39;);
new PersonProxy(&#39;jack&#39;);

console.log(people); // [ Person &#123; name: &#39;john&#39; &#125;, Person &#123; name: &#39;jack&#39; &#125; ]
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>代理是 ECMAScript 6 新增的令人兴奋和动态十足的新特性。尽管不支持向后兼容，但它开辟出了一片前所未有的 JavaScript 元编程及抽象的新天地。</p>
<p>从宏观上看，代理是真实 JavaScript 对象的透明抽象层。代理可以定义包含捕获器的处理程序对象，而这些捕获器可以拦截绝大部分 JavaScript 的基本操作和方法。在这个捕获器处理程序中，可以修改任何基本操作的行为，当然前提是遵从捕获器不变式。</p>
<p>与代理如影随形的反射 API，则封装了一整套与捕获器拦截的操作相对应的方法。可以把反射 API 看作一套基本操作，这些操作是绝大部分 JavaScript 对象 API 的基础。</p>
<p>代理的应用场景是不可限量的。开发者使用它可以创建出各种编码模式，比如（但远远不限于）跟踪属性访问、隐藏属性、阻止修改或删除属性、函数参数验证、构造函数参数验证、数据绑定，以及可观察对象。</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>代理</tag>
        <tag>Proxy</tag>
        <tag>反射</tag>
        <tag>Reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript面向对象</title>
    <url>/2021/06/27/javascript/javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>本文介绍了 javascript 中创建对象的方法以及实现继承的方法。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<h1 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h1><p>在 ES6 中类的概念出现之前，主要有以下创建对象的方法。注，ES6 的类都仅仅是封装了 ES5.1 构造函数加原型继承的语法糖而已。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是一种众所周知的设计模式，广泛应用于软件工程领域，用于抽象创建特定对象的过程。</p>
<pre><code>function createPerson(name, age, job) &#123;
  let o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function () &#123;
    console.log(this.name);
  &#125;;
  return o;
&#125;
let person1 = createPerson(&#39;Nicholas&#39;, 29, &#39;Software Engineer&#39;);
let person2 = createPerson(&#39;Greg&#39;, 27, &#39;Doctor&#39;);
</code></pre>
<h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><pre><code>function Person(name, age, job) &#123;
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function () &#123;
    console.log(this.name);
  &#125;;
&#125;
let person1 = new Person(&#39;Nicholas&#39;, 29, &#39;Software Engineer&#39;);
let person2 = new Person(&#39;Greg&#39;, 27, &#39;Doctor&#39;);
person1.sayName(); // Nicholas￼
person2.sayName(); // Greg
</code></pre>
<p>执行 new 操作符时，引擎内部会执行如下操作：</p>
<ul>
<li>在内存中创建一个新对象。</li>
<li>这个新对象内部的[[Prototype]]特性被赋值为构造函数的 prototype 属性。</li>
<li>构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。</li>
<li>执行构造函数内部的代码（给新对象添加属性）。</li>
<li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</li>
</ul>
<p>构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。因此对前面的例子而言，person1 和 person2 都有名为 sayName()的方法，但这两个方法不是同一个 Function 实例。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型。</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>ECMA-262 把原型链定义为 ECMAScript 的主要继承方式。其基本思想就是通过原型继承多个引用类型的属性和方法。</p>
<p>重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。</p>
<p>原型链虽然是实现继承的强大工具，但它也有问题。主要问题出现在原型中包含引用值的时候。前面在谈到原型的问题时也提到过，原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。</p>
<p>原型链的第二个问题是，子类型在实例化时不能给父类型的构造函数传参。事实上，我们无法在不影响所有对象实例的情况下把参数传进父类的构造函数。再加上之前提到的原型中包含引用值的问题，就导致原型链基本不会被单独使用。</p>
<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>为了解决原型包含引用值导致的继承问题，一种叫作“盗用构造函数”（constructor stealing）的技术在开发社区流行起来（这种技术有时也称作“对象伪装”或“经典继承”）。基本思路很简单：在子类构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用 apply()和 call()方法以新创建的对象为上下文执行构造函数。</p>
<ol>
<li>传递参数</li>
</ol>
<p>相比于使用原型链，盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参。</p>
<pre><code>function SuperType(name) &#123;
  this.name = name;
&#125;

function SubType() &#123;
  // 继承SuperType并传参￼
  SuperType.call(this, &#39;Nicholas&#39;);
  // 实例属性￼
  this.age = 29;
&#125;

let instance = new SubType();
console.log(instance.name); // &quot;Nicholas&quot;;
console.log(instance.age); // 29
</code></pre>
<ol start="2">
<li>盗用构造函数的问题</li>
</ol>
<p>盗用构造函数的主要缺点，也是使用构造函数模式自定义类型的问题：必须在构造函数中定义方法，因此函数不能重用。此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。由于存在这些问题，盗用构造函数基本上也不能单独使用。</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。</p>
<p>组合继承弥补了原型链和盗用构造函数的不足，是 JavaScript 中使用最多的继承模式。而且组合继承也保留了 instanceof 操作符和 isPrototypeOf()方法识别合成对象的能力。</p>
<pre><code>function SuperType(name) &#123;
  this.name = name;
  this.colors = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];
&#125;
SuperType.prototype.sayName = function () &#123;
  console.log(this.name);
&#125;;
function SubType(name, age) &#123;
  SuperType.call(this, name); //第二次调用SuperType()
  this.age = age;
&#125;
SubType.prototype = new SuperType(); //第一次调用SuperType()
SubType.prototype.constructor = SubType;
SubType.prototype.sayAge = function () &#123;
  console.log(this.age);
&#125;;
</code></pre>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>JavaScript 的继承主要通过原型链来实现。原型链涉及把构造函数的原型赋值为另一个类型的实例。这样一来，子类就可以访问父类的所有属性和方法，就像基于类的继承那样。原型链的问题是所有继承的属性和方法都会在对象实例间共享，无法做到实例私有。</p>
<p>盗用构造函数模式通过在子类构造函数中调用父类构造函数，可以避免这个问题。这样可以让每个实例继承的属性都是私有的，但要求类型只能通过构造函数模式来定义（因为子类不能访问父类原型上的方法）。</p>
<p>目前最流行的继承模式是组合继承，即通过原型链继承共享的属性和方法，通过盗用构造函数继承实例属性。</p>
<h2 id="其他继承方式"><a href="#其他继承方式" class="headerlink" title="其他继承方式"></a>其他继承方式</h2><p>除上述模式之外，还有以下几种继承模式。<br>❑ 原型式继承可以无须明确定义构造函数而实现继承，本质上是对给定对象执行浅复制。这种操作的结果之后还可以再进一步增强。<br>❑ 与原型式继承紧密相关的是寄生式继承，即先基于一个对象创建一个新对象，然后再增强这个新对象，最后返回新对象。这个模式也被用在组合继承中，用于避免重复调用父类构造函数导致的浪费。<br>❑ 寄生组合继承被认为是实现基于类型继承的最有效方式。</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>2006 年，Douglas Crockford 写了一篇文章：《JavaScript 中的原型式继承》（“Prototypal Inheritance in JavaScript”）。这篇文章介绍了一种不涉及严格意义上构造函数的继承方法。他的出发点是即使不自定义类型也可以通过原型实现对象之间的信息共享。文章最终给出了一个函数：</p>
<pre><code>function object(o) &#123;
  function F() &#123;&#125;
  F.prototype = o;
  return new F();
&#125;
</code></pre>
<p>Crockford 推荐的原型式继承适用于这种情况：你有一个对象，想在它的基础上再创建一个新对象。你需要把这个对象先传给 object()，然后再对返回的对象进行适当修改。</p>
<p>ECMAScript 5 通过增加 Object.create()方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>与原型式继承比较接近的一种继承方式是寄生式继承（parasitic inheritance），也是 Crockford 首倡的一种模式。寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。</p>
<pre><code>function createAnother(original) &#123;
  let clone = object(original); // 通过调用函数创建一个新对象
  clone.sayHi = function () &#123;
    // 以某种方式增强这个对象￼
    console.log(&#39;hi&#39;);
  &#125;;
  return clone; // 返回这个对象
&#125;
</code></pre>
<p>寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景。object()函数不是寄生式继承所必需的，任何返回新对象的函数都可以在这里使用。注意: 通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。</p>
<h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><p>组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在子类构造函数中调用。本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。</p>
<h1 id="ES6-Class"><a href="#ES6-Class" class="headerlink" title="ES6 Class"></a>ES6 Class</h1><p>抽象基类<br>有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。虽然 ECMAScript 没有专门支持这种类的语法，但通过 new.target 也很容易实现。</p>
<p>new.target 保存通过 new 关键字调用的类或函数。通过在实例化时检测 new.target 是不是抽象基类，可以阻止对抽象基类的实例化：</p>
<pre><code>// 使用 new.target 实现 ES6 抽象基类
class Vehicle &#123;
  constructor() &#123;
    console.log(new.target);
    if (new.target === Vehicle) &#123;
      throw new Error(&#39;Vehicle cannot be directly instantiated&#39;);
    &#125;
  &#125;
&#125;

new Vehicle(); // Error: Vehicle cannot be directly instantiated
</code></pre>
<p>另外，通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法。因为原型方法在调用类构造函数之前就已经存在了，所以可以通过 this 关键字来检查相应的方法：</p>
<pre><code>// 抽象基类
class Vehicle &#123;
  constructor() &#123;
    if (new.target === Vehicle) &#123;
      throw new Error(&#39;Vehicle cannot be directly instantiated&#39;);
    &#125;

    if (!this.foo) &#123;
      throw new Error(&#39;Inheriting class must define foo()&#39;);
    &#125;
    console.log(&#39;success! &#39;);
  &#125;
&#125;

// 派生类
class Bus extends Vehicle &#123;
  foo() &#123;&#125;
&#125;

// 派生类
class Van extends Vehicle &#123;&#125;

new Bus(); // success!
new Van(); // Error: Inheriting class must define foo()
</code></pre>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>面向对象</tag>
        <tag>原型继承</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员的反思</title>
    <url>/2021/08/09/web%E5%89%8D%E7%AB%AF/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%8F%8D%E6%80%9D/</url>
    <content><![CDATA[<p>本文转自微信公众号文章 <a href="https://mp.weixin.qq.com/s/R182NTXIR-qaewOOTE4sOA">看完左耳朵耗子的文章，我才明白为啥他技术那么厉害</a>。</p>
<p>大概 4 年前，知名技术专家左耳朵耗子在极客时间上开设了一个全年付费专栏。到现在，这个专栏已经有 5.7 万人订阅，结束语里有用户这么评价这个专栏：</p>
<pre><code>感谢耗子哥，此时此刻，有感慨，更多的是感动，感谢您给我们分享了这么多知识和人生经验，通过这个专栏收获了很多，我以前做了太多重复性工作，自己没有一点提升，一直感到迷茫，没有方向，对自己的职业生涯完全没有目标和规划，荒废了很多年时间。看了你的文章，我有了改变，最近几个月我都在坚持看书，也有了比较清晰的目标，有时我想要是早五年看到这个专栏有多好。没有后悔药，这是我必须付出的代价，现在已经 30+ 了，我希望现在努力还不晚。我想我会持续关注耗子哥的博客，3 年后我希望我有质的改变和提升。
</code></pre>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<p>以下是具体内容。</p>
<ol>
<li>程序员用自己的技术变现，其实是一件天经地义的事儿。写程序是一门“手艺活”，作为手艺人，程序员当然可以做到靠自己的手艺和技能养活自己。然而，现在很多手艺人程序员却说自己是“码农”，编码的农民工，在工作上被各种使唤，各种加班，累得像个牲口。在职业发展上各种迷茫和彷徨，完全看不到未来的希望，更别说可以成为一个手艺人用自己的技能变现了。</li>
<li>成为一个手艺人，动手能力是很重要的，因为在解决任何一个具体问题的时候，有没有动手能力就成为了关键。这也是我一直在写代码的原因，代码里全是细节，细节是魔鬼，只有了解了细节，你才能提出更好或是更靠谱、可以落地的解决方案，而不是一些笼统和模糊的东西。这太重要了。</li>
<li>会挣钱的人一定是会投资的人。我一直认为，最宝贵的财富并不是钱，而是你的时间，时间比钱更宝贵，因为钱你不用还在那里，而时间你不用就浪费掉了。你把你的时间投资在哪些地方，就意味着你未来会走什么样的路。所以，利用好你的时间，投到一些有意义的地方吧。</li>
<li>在学习新技术的过程一定要多问自己两个问题。第一，这个技术解决什么问题？为什么别的同类技术做不到？第二，为什么是这样解决的？有没有更好的方式？千万别一上来就陷入细节。</li>
<li>只有那些在高速发展的公司，技术人员的价值才能被最大化地体现出来。比较好的成长路径是，先进入大公司学习大公司的技术和成功的经验方法，然后再找到高速成长的公司，这样你就可以实现自己更多的价值。当然，这里并不排除在大公司中找到高速发展的业务。</li>
<li>解决一个问题通常有很多种方法。带着开放的心态，不拘泥于一个平台、一种语言，往往能带来更多思考，也能得到更好的结果。而且，能在不同的方法和方案间做比较，比较它们的优缺点，那么你会知道在什么样的场景下用什么样的方案，你就会比一般人能够有更全面和更完整的思路。</li>
<li>什么是技术领导力？一句话总结就是遇到问题时，你能够提供有建设性的意见。</li>
<li>对于我们每个人来说，作品集会比简历更有参考意义。所以，在自己的简历中应该放上自己的一些项目经历，或是一些开源软件的贡献。</li>
<li>如果一个公司或者一个人能够抓住技术红利，那就会比其它公司或个人有更大的影响力。一旦未来行业需求引爆，那么这个公司或这个人的影响力就会形成一个比较大的护城河，并可以快速地从中获取经济利益。</li>
<li>Go 语言不会吞食底层到 C 和 C++ 那个级别的，也不会吞食到上层如 Java 业务层的项目。Go 语言能吞食的一定是 PaaS 上的项目，比如一些消息缓存中间件、服务发现、服务代理、控制系统、Agent、日志收集等等，他们没有复杂的业务场景，也到不了特别底层（如操作系统）的软件项目或工具。而 C 和 C++ 会被打到更底层，Java 会被打到更上层的业务层。这是我的一个判断。</li>
<li>找到自己的长处，不断地在自己的长处上发展自我。知道自己几斤几两才能清楚自己适合干什么。不然，目标设置得过高自己达不到，反而让自己难受。在职场上，审视自己的最佳方式，就是隔三差五就出去面试一把，看看自己在市场上能够到什么样的级别。如果你超过了身边的大多数人，你不妨选择得激进一些冒险一些，否则，还是按部就班地来吧。</li>
<li>30-40 岁，这是人生发展的阶段。因为整个社会一定会把社会的重担交给这群人，30-40 岁的人年富力强，既有经验又有精力，还敢想敢干，所以这群人才是整个社会的中流砥柱。在这个阶段，你需要明确自己奋斗的方向，需要做有挑战的事儿，需要提升自己的技术领导力。</li>
<li>加班太严重完全没有时间学习，怎么办？我觉得，可能并不在于加班和工作强度大到没时间，关键看你对学习有多少的渴望程度，对要学的东西有多大的热情。这点是非常重要的，因为学习这事其实挺反人性的。反人性的事基本上都是要付出很多，而且还要坚持很久。所以，如果对学习没有渴望的话，或是不能从学习中找到快乐的话，那么其实是很难坚持的，无论你有没有时间。</li>
<li>别人愿意跟随你，愿意和你共事，有一部分原因是你能够给别人带来更多的可能性和机会，别人觉得和你在一起能够成长，能够进步，你能够带着大家到达更远的地方。帮助别人其实就是帮助自己，成就他人其实也是在成就自己，这就像一个好的足球队一样，球队中的人都互相给队友创造机会，整个团队成功了，球队的每个人也就成功了。作为一个好的 Leader，你一定要在团队中创造好这样的文化和风气。</li>
<li>我觉得今天大多数的会都开错了。在会上抛出问题，还是开放性的问题，然后公说公有理，婆说婆有理，任大家自由发挥，各种跑题跑偏，最后还没有任何的答案。开会，不是讨论问题，而是讨论方案，开会不是要有议题，而是要有议案。</li>
<li>学习是逆人性的事儿，但如果在学习过程中不断地有正反馈，就更利于我们坚持下去。要让自己有正反馈，那就需要把时间花在有价值的地方，比如，解决自己和他人的痛点，这样你会收获别人的赞扬和鼓励。</li>
<li>在参加工作的这 20 年时间里，我发现，很多程序员都把时间都浪费在了查错上。究其根本原因就是基础知识不完整，没有好好地把技术相关的用户文档读完就仓促上手做事情了。其实只要把基础打扎实，认真读一下文档，你会省出很多很多的时间。系统地学习一门技术是非常关键的，所以这个时间是值得投资的。</li>
<li>一个可以持久的兴趣，或是可以培养出来的兴趣，后面都有一个比较本质的东西，其实就是成就感，他是你坚持或者努力的最直接的正反馈。也就是说，兴趣只是开始，而能让人不断投入时间和精力的则是正反馈，是成就感。</li>
<li>与其花时间在 Git 协同工作流上，还不如把时间花在调整软件架构和自动化软件生产和运维流程上来，这才是真正简化协同工作流程的根本。</li>
<li>编程范式其实就是程序的指导思想，它也代表了这门语言的设计方向，我们并不能说哪种范式更为超前，只能说各有千秋。比如 C 语言就是过程式的编程语言，像 C 语言这样的过程式编程语言优点是底层灵活而且高效，特别适合开发运行较快且对系统资源利用率要求较高的程序，但我上面抛出的问题它在后来也没有试图去解决，因为编程范式的选择基本已经决定了它的“命运”。</li>
<li>亚马逊的 AWS 才会把 Design for Failure 作为其七大 Design Principle 的重点。这告诉我们，不要尝试着去避免故障，而是要把处理故障的代码当成正常的功能做在架构里写在代码里。因为我们要干的事儿就是想尽一切手段来降低 MTTR——故障的修复时间。</li>
<li>隔离设计对应的单词是 Bulkheads，中文翻译为隔板。但其实，这个术语是用在造船上的，也就是船舱里防漏水的隔板。一般的船无论大小都会有这个东西，大一点的船都会把船舱隔成若干个空间。这样，如果船舱漏水，只会进到一个小空间里，不会让整个船舱都进水而导致整艘船都沉了。</li>
<li>通讯一般来说分同步和异步两种。同步通讯就像打电话，需要实时响应，而异步通讯就像发邮件，不需要马上回复。各有千秋，我们很难说谁比谁好。但是在面对超高吐吞量的场景下，异步处理就比同步处理有比较大的优势了，这就好像一个人不可能同时接打很多电话，但是他可以同时接收很多的电子邮件一样。</li>
<li>所谓幂等性设计，就是说，一次和多次请求某一个资源应该具有同样的副作用。用数学的语言来表达就是：f(x) = f(f(x))。</li>
<li>ACID 的玩法就是，大家在买同一本书的过程中，每个用户的购买请求都需要把库存锁住，等减完库存后，把锁释放出来，后续的人才能进行购买。于是，在 ACID 的玩法下，我们在同一时间不可能有多个用户下单，我们的订单流程需要有排队的情况，这样一来，我们就不可能做出性能比较高的系统来。BASE 的玩法是，大家都可以同时下单，这个时候不需要去真正地分配库存，然后系统异步地处理订单，而且是批量的处理。因为下单的时候没有真正去扣减库存，所以，有可能会有超卖的情况。而后台的系统会异步地处理订单时，发现库存没有了，于是才会告诉用户你没有购买成功。</li>
<li>熔断机制这个词对你来说肯定不陌生，它的灵感来源于我们电闸上的“保险丝”，当电压有问题时（比如短路），自动跳闸，此时电路就会断开，我们的电器就会受到保护。不然，会导致电器被烧坏，如果人没在家或是人在熟睡中，还会导致火灾。所以，在电路世界通常都会有这样的自我保护装置。</li>
<li>所谓的降级设计（Degradation），本质是为了解决资源不足和访问量过大的问题。当资源和访问量出现矛盾的时候，在有限的资源下，为了能够扛住大量的请求，我们就需要对系统进行降级操作。也就是说，暂时牺牲掉一些东西，以保障整个系统的平稳运行。</li>
<li>技术能力的瓶颈，以及技术太多学不过来，只不过是你为自己的能力不足或是懒惰找的借口罢了。技术的东西都是死的，这些死的知识只要努力就是可以学会的。只不过聪明的人花得时间少，笨点的人花得时间多点罢了。这其中的时间差距主要是由学习方法的不同，基础知识储备的不同决定的。只要你方法得当，多花点时间在基础知识上，会让你未来学习应用知识的时间大大缩短。以绝大多数人努力的程度，和为自己不努力找借口的程度为参考，只要你坚持正常的学习就可以超过大多数人了。</li>
<li>要应付并通过面试并不难，但是，千万不要应付你的人生，你学技术不是用来面试的，它至少来说是你谋生的技能，要尊重自己的谋生技能，说不定，哪天你还要用这些技能造福社会、改变世界的。</li>
<li>学习不是努力读更多的书，盲目追求阅读的速度和数量，这会让人产生低层次的勤奋和成长的感觉，这只是在使蛮力。要思辨，要践行，要总结和归纳，否则，你只是在机械地重复某件事，而不会有质的成长的。</li>
<li>把你看到和学习到的信息，归整好，排列好，关联好，总之把信息碎片给结构化掉，然后在结构化的信息中，找到规律，找到相通之处，找到共同之处，进行简化、归纳和总结，最终形成一种套路，一种模式，一种通用方法。</li>
<li>坚持也不是要苦苦地坚持，有循环有成就感的坚持才是真正可以持续的。所以，一方面你要把你的坚持形成成果晒出来，让别人来给你点赞，另一方面，你还要把坚持变成一种习惯，就像吃饭喝水一样，你感觉不到太多的成本付出。只有做到这两点，你才能够真正坚持。</li>
<li>把你新学的知识点关联到已知的事物上来。比如，你在学习 Go 语言，你就把一些知识关联到自己已经学过的语言上比如 C 和 Java。通过类比，你会学得更扎实，也会思考得更多。</li>
<li>对于技术人员来说，其实，Talk 和 Code 是同样重要的， Talk 是人对人说的话，而 Code 也不仅仅只是人对机器说的话，也更是另外一种人对人说的话（因为 Code 需要易读和易维护，就需要让人读懂）。可见，无论是 Code 还是 Talk 其实都是要和人交流的，Code 是间接交流，Talk 则是直接交流。</li>
<li>每个人都应该为自己的事业、为自己的理想去活一次，追逐自己的事业和理想并不容易，需要有很大付出，也只有你内心的那个理想才值得这么大的付出……</li>
<li>挣钱是一件大家都想做的事，但你得解决一个很核心的问题，那就是为什么别人愿意给你钱？对于挣钱这件事的看法，我从大学毕业到现在都没怎么变过，那就是我更多关注怎么提高自己的能力，让自己值那个价钱，让别人愿意付钱。另外，我发现越是有能力的人，就越不计较一些短期得失，越计较短期得失的人往往都是很平庸的人。</li>
<li>从客观规律上来说，某件事的进步一定会和现状有一些摩擦。有的人害怕摩擦而选择忍耐，我则不是，我觉得与别人的摩擦并不可怕，因为大家的目标都是基本一致的，只是做事的标准和方式不一样，这是可以沟通和相互理解的。</li>
<li>我选择了一个正确的专业（计算机科学），待在了一个正确的年代（信息化革命），这样的“狗屎运”几百年不遇，如果我还患得患失，那我岂不辜负了活在这样一个刺激的时代？！我只需要在这个时代中做有价值的事就好了！</li>
</ol>
]]></content>
      <categories>
        <category>职业思考</category>
      </categories>
      <tags>
        <tag>反思</tag>
      </tags>
  </entry>
  <entry>
    <title>前端监控思路和实现</title>
    <url>/2021/07/05/web%E5%89%8D%E7%AB%AF/%E7%AB%AF%E7%9B%91%E6%8E%A7%E6%80%9D%E8%B7%AF%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>前端监控主要包括信息的采集、上报和告警。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<h2 id="前端需要监控什么内容"><a href="#前端需要监控什么内容" class="headerlink" title="前端需要监控什么内容"></a>前端需要监控什么内容</h2><ol>
<li>错误监控<ul>
<li>1.1 js 执行错误</li>
<li>1.2 ajax 错误</li>
<li>1.3 promise 错误</li>
<li>1.4 静态资源加载错误</li>
<li>1.5 本地输入的 console 日志</li>
</ul>
</li>
<li>CGI 测速（响应码、响应耗时）</li>
<li>静态资源质量（耗时）</li>
<li>页面质量（首屏耗时）</li>
<li>平台或网络信息</li>
</ol>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="错误监控"><a href="#错误监控" class="headerlink" title="错误监控"></a>错误监控</h3><ol>
<li>js 脚本执行错误时会触发页面的 onerror 事件，通过该事件可以捕获到脚本执行错误。</li>
</ol>
<pre><code>window.onerror = function(message, source, lineno, colno, error) &#123;
    // message: 错误信息
    // source: 发生错误的脚本URL
    // lineno: 发生错误的行号
    // colno: 发生错误的列号
    // error： 错误对象
&#125;
</code></pre>
<ol start="2">
<li>静态资源加载错误时，会被 <code>window.addEventListener(&#39;error&#39;, func, true)</code>(注意第三个参数) 捕获。</li>
</ol>
<pre><code>// 捕获静态资源加载错误
// 注意第三个参数为true，表示要在事件捕获阶段处理
window.addEventListener(&#39;error&#39;, function(e)&#123;
    // 上报错误
&#125;, true);
</code></pre>
<ol start="3">
<li>promise 异常会触发页面的 unhandledrejection 事件，可以通过该事件捕获异常。</li>
</ol>
<pre><code>window.addEventListener(&#39;unhandledrejection&#39;, function(err) &#123;
    // 上报错误
&#125;, true);
</code></pre>
<ol start="4">
<li>CGI 监控</li>
</ol>
<p>CGI 监控的方式有两种，一种是业务方接口调用失败时，主动上报；另一种是改写 ajax 和 fetch 方法来实现上报。第二种方法对业务无侵入，比较灵活，但是上报信息可能不如第一种详细。</p>
<pre><code>//改写 fetch
function overrideFetch() &#123;
  ...
  const originFetch = window.fetch;
  window.fetch = (url, option) =&gt; &#123;
    return originFetch(url, option)
    .then(res =&gt; &#123;
      // 在这里拦截到接口请求情况进行上报处理
      ...
    &#125;)
  &#125;
&#125;

// 改写XHR
const xhrProto = window.XMLHttpRequest.prototype,
    originSend = xhrProto.send;
    xhrProto.send = function aegisFakeXhrSend() &#123;
    // 在这里获取请求情况进行上报处理
    ...
    return originSend.apply(this, arguments)
&#125;
</code></pre>
<ol start="5">
<li>console 日志监控</li>
</ol>
<p>前端代码中经常会使用 console 来打印日志，其中 console.error 中抛出的信息可能对我们有用。可以通过改写底层的 console.error 方法来上报数据。</p>
<pre><code>if (typeof console !== &#39;undefined&#39; &amp;&amp; typeof console.error === &#39;function&#39;) &#123;
    const nativeConsoleError = console.error;
    console.error = (...rest) =&gt; &#123;
    nativeConsoleError.apply(window.console, rest);
    // 发送错误信息到服务器
    &#125;;
&#125;
</code></pre>
<h3 id="静态资源质量"><a href="#静态资源质量" class="headerlink" title="静态资源质量"></a>静态资源质量</h3><p>前端静态资源主要包括 img、css、script、link、audio、video 这几大块内容。可以通过 performance API 来收集所有静态资源的请求情况，然后利用 performance.timing 获取每个时间节点来计算静态资源的加载情况。</p>
<pre><code>function collect() &#123;
    const entries = performance.getEntriesByType(&#39;resource&#39;);

    for (let i = 0, l = entries.length; i &lt; l; i++) &#123;
        const entry = entries[i] as StaticPerformanceResourceTiming;
        if ([&#39;link&#39;, &#39;img&#39;, &#39;script&#39;].includes(entry.initiatorType)) &#123;
            // dns解析时间
            const DNSResolveTime = entry.domainLookupEnd - entry.domainLookupStart;
            // 响应总时间
            const respTime = entry.responseEnd - entry.startTime;
            // 其他时间，参考 performance API

            const resourceName = entry.name;
            // 上报
            report(&#123; event: &#39;static-resource&#39;, name: resourceName, data: &#123; DNSResolveTime, respTime&#125; &#125;);
        &#125;
    &#125;
&#125;

// 可以开启定时器，定时收集上报
setInterval(collect, this.config.collectInterval);
</code></pre>
<h3 id="CGI-测速"><a href="#CGI-测速" class="headerlink" title="CGI 测速"></a>CGI 测速</h3><p>同样的，通过改写 ajax 和 fetch，可以获取请求和响应的时间点，从而计算得出 CGI 的请求耗时。</p>
<h3 id="页面质量"><a href="#页面质量" class="headerlink" title="页面质量"></a>页面质量</h3><p>在页面性能中，最重要的是计算<code>首屏渲染时间</code>。</p>
<p>由于 React 、Vue 等框架的出现，DOMContentLoaded 事件已经失去了原本的作用，现在 “首屏渲染时间” 的计算大多数时候是依靠人工打点，这样会侵入业务，使用不便。下面介绍一套新的算法，尽可能准确的对 “首屏渲染时间” 进行估算，主要运用到了 MutationObserver、performance。</p>
<p>MutationObserver 提供了监听页面 DOM 树变化的能力：</p>
<pre><code>// 注册监听函数
const observer = new MutationObserver((mutations) =&gt; &#123;
    // 获取增加的节点
    for(let i = 0; i &lt; mutations.length; i++) &#123;
        console.log(mutations[0].addedNodes);
    &#125;
&#125;);

// 监听 document 的节点变化
observer.observe(document, &#123;
    childList: true,
    subtree: true
&#125;);
</code></pre>
<p><code>performance</code> API 能计算资源加载的时间（详见上文静态资源收集）</p>
<p>通过 MutationObserver 观察页面 dom 树的变化，只关心 nodeType === 1 的元素，且剔除 script、style 等不会在页面中展示出来的元素节点，最后比较找出<code>首屏节点完成耗时最大的一个</code>作为 firstScreenTiming 首屏渲染时间。</p>
<p>但这个 firstScreenTiming 首屏渲染时间还不是最终确认得到的最大渲染时间，我们都知道页面的“加载完整”除了节点元素加载完毕外，首屏中的图片加载完成也是一个判断标准。得益于浏览器提供的 performance API ，这个计算过程非常简单高效。</p>
<pre><code>window.performance.getEntriesByType(&#39;resource&#39;).forEach((resource: any) =&gt; &#123;
    if (
        resource.initiatorType === &#39;img&#39; &amp;&amp;
        resource.responseEnd &gt; maxTime
    )&#123;
        //遍历找出图片资源加载中耗时最大的一个
        //并与 DOM 节点加载得到的‘首屏渲染时间’比较，取最大的值作为真正的 firstScreenTiming
    &#125;
&#125;);
</code></pre>
<h3 id="平台或网络信息"><a href="#平台或网络信息" class="headerlink" title="平台或网络信息"></a>平台或网络信息</h3><p>平台设备信息可以通过 UserAgent 解析而来。</p>
<p>网络信息可以通过 navigator.connection API 获取到。</p>
<pre><code>const result = navigator.connection;
result.effectiveType; // 2g, 3g, 4g, 5g, wifi ... 注意，该结果是浏览器根据当前网速的测算值，不一定准确
result.downlink;      // 网络下行速度，单位为 Mbits/s
result.rtt;           // 估算的往返时间
result.obChange = function()&#123;&#125;;  // 网络变更时触发
</code></pre>
<h2 id="离线日志"><a href="#离线日志" class="headerlink" title="离线日志"></a>离线日志</h2><p>可以考虑使用 IndexedDB 在用户本地存储离线日志，这样就算因为用户网络不佳，无法进行通信，日志也会被记录下来，在后续合适的时机进行上报。</p>
<h2 id="数据上报和告警"><a href="#数据上报和告警" class="headerlink" title="数据上报和告警"></a>数据上报和告警</h2><p>可以使用 ElasticSearch 来存储日志，配合 Kibana 查询展示。</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>前端监控</tag>
      </tags>
  </entry>
  <entry>
    <title>总览</title>
    <url>/2021/08/03/javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%80%BB%E8%A7%88/</url>
    <content><![CDATA[<p>本文对项目中常用的设计模式做一句话简单介绍。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><ul>
<li>单一职责原则： 一个类应该只负责一个职责。术语叫：仅有一个引起其变化的原因。简单点说：一个类中应该是一组相关性很高的函数及数据的封装。</li>
<li>开闭原则： 一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</li>
<li>里氏替换原则： 所有引用基类（父类）的地方必须能透明地使用其子类的对象。</li>
<li>依赖倒置原则： 抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</li>
<li>接口隔离原则： 使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</li>
<li>迪米特法则： 也叫最少知识原则，是指一个对象应该尽可能少地了解另外的对象（中介者模式是一种典型实现）。</li>
</ul>
<h2 id="常用设计模式总览"><a href="#常用设计模式总览" class="headerlink" title="常用设计模式总览"></a>常用设计模式总览</h2><ul>
<li>单例模式： 保证全局对象唯一性。</li>
<li>策略模式： 定义一系列算法，把它们一个个封装起来，并且使他们可以相互替换。</li>
<li>代理模式： 定义一个替身对象来控制对实际目标对象的访问，代理和本体需保持接口一致性。</li>
<li>迭代器模式： 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</li>
<li>发布订阅模式： 又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在JavaScript开发中，我们一般用事件模型来替代传统的发布—订阅模式。</li>
<li>命令模式： 命令模式中的命令（command）指的是一个执行某些特定事情的指令。命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。</li>
<li>组合模式： 对象组合成树形结构，以表示“部分-整体”的层次结构。除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性。</li>
<li>模板方法模式： 模板方法模式是一种只需使用继承就可以实现的非常简单的模式。模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。</li>
<li>享元模式： 享元（flyweight）模式是一种用于性能优化的模式，“fly”在这里是苍蝇的意思，意为蝇量级。享元模式的核心是运用共享技术来有效支持大量细粒度的对象。如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了。</li>
<li>职责链模式： 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</li>
<li>中介者模式： 中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系。</li>
<li>装饰者模式： 动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。</li>
<li>状态模式： 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</li>
<li>适配器模式：解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。</li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>江雪</title>
    <url>/2021/06/28/%E8%AF%97%E8%AF%8D/%E6%B1%9F%E9%9B%AA/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>诗词</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>柳宗元</tag>
      </tags>
  </entry>
  <entry>
    <title>遇见春天遇见你</title>
    <url>/2021/06/22/%E8%AF%97%E8%AF%8D/%E9%81%87%E8%A7%81%E6%98%A5%E5%A4%A9%E9%81%87%E8%A7%81%E4%BD%A0/</url>
    <content><![CDATA[<p>沾衣欲湿杏花雨，春风十里不如你。</p>
<p>东晋永和年间，一个叫祝英台的姑娘，女扮男装，在一个明媚的春天，走出家门，去杭城求学，在春天的路上，他碰到了一个叫梁山伯的小伙子，他们草桥结拜，开始了一段化蝶的传说。一千多年来，你依旧可以在花海树影中，看到他们双宿双飞，为爱徘徊。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<p>东晋咸安年间，正当壮年的王献之走出家门，在桃花汛到来的时节，来到金陵的河边，在一个渡口，碰到一个叫桃叶的姑娘，从此金风玉露一相逢，便胜却人间无数。后来这个渡口也因为他们的相遇，从此被叫做桃叶渡。</p>
<p>大唐贞元十一年，落榜的考生崔护，在百无聊赖中去郊外春游，只是因为口渴讨水，便遇到一个叫绛娘的姑娘。第二年，他念念不忘，又有回想，又在春天重游故地，在绛娘家的门上，留下一首绝句。去年今日此门中，人面桃花相映红，人面不知何处去，桃花依旧笑春风。绛娘因此死，绛娘因此生，崔护也因此名传千古。</p>
<p>大唐元和四年，三十岁的袁震任监察御史，出使西蜀，当时正值春天，意气风发的袁震来到西川，和才女薛涛在那个山花烂漫的春天里，开始了一段惊天动地的姐弟恋。</p>
<p>事实上，春天的故事远不止这些。</p>
<p>墙头马上里的李千金，只因为是春天，忍不住站在墙边的软梯上，探头向外一望，就望见了那个比裴勇俊还要帅上几分的裴少俊。据说，唐伯虎也是在春游灵隐寺的时候，初见秋香，惊为天人。浮生六记里的沈复和芸娘，他们的春游更成为那个时代的经典。至于白娘子之遇许仙，完全是因为一千七百年前的一个小牧童，在春天放牧的时候，救了一小白蛇，然后才有了一千七百年后的西湖边的春天，他们断桥的遇见。</p>
<p>所以美丽的春天，不适合做宅女，不适合做宅男。</p>
<p>春天万物生发，生机盎然，适合走出门去，在生命最好的时候，让上苍恩赐一场遇见。</p>
<p>春风十里不如你啊，从一个日子走向另外一个日子，从一个春天走向另外一个春天，从一个自己走向另外一个自己。</p>
<p>跋涉的时候，遇见风，遇见雨，遇见他们，遇见星辰。</p>
<p>驻足的时候，遇见来，遇见去，遇见欢喜。</p>
<p>人生就是在路上，路上最大的幸福，就是遇见春天，遇见你。</p>
]]></content>
      <categories>
        <category>诗词</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>春天</tag>
      </tags>
  </entry>
  <entry>
    <title>从浏览器输入URL到显示页面发生了什么</title>
    <url>/2021/07/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>从浏览器输入网址到页面显示的全过程。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<h2 id="流程概览"><a href="#流程概览" class="headerlink" title="流程概览"></a>流程概览</h2><ol>
<li>web 浏览器： 当我们输入网址时，浏览器就会按照一定的规则去分析这个网址的含义，然后根据其含义生成请求消息；接着浏览器会将请求消息发送给 Web 服务器。当然，浏览器并不会亲自负责数据的传送。传送消息是搬运数字信息的机制负责的工作，因此浏览器会委托它将数据发送出去。具体来说，就是委托操作系统中的网络控制软件将消息发送给服务器。</li>
<li>协议栈、网卡： 协议栈（网络控制软件叫作协议栈）这个软件会将从浏览器接收到的消息打包，然后加上目的地址等控制信息。如果拿邮局来比喻，就是把信装进信封，然后在信封上写上收信人的地址。这个软件还有其他一些功能，例如当发生通信错误时重新发送包，或者调节数据发送的速率等，或许我们可以把它当作一位帮我们寄信的小秘书。接下来，协议栈会将包交给网卡（负责以太网或无线网络通信的硬件）。然后，网卡会将包转换为电信号并通过网线发送出去。这样一来，包就进入到网络之中了。</li>
<li>集线器、交换机、路由器： 接下来出场的物品会根据接入互联网的形式不同而不同。客户端计算机可以通过家庭或公司的局域网接入互联网，也可以单独直接接入互联网。以现在最典型的场景为例，假设客户端计算机是连接到家庭或公司的局域网中，然后再通过 ADSL 和光纤到户（FTTH）等宽带线路接入互联网。在这样的场景中，网卡发送的包会经过交换机等设备，到达用来接入互联网的路由器。路由器的后面就是互联网，网络运营商会负责将包送到目的地，就好像我们把信投到邮筒中之后，邮递员会负责把信送给收件人一样。</li>
<li>接入网、网络运营商： 接下来，数据从用来接入互联网的路由器出发，进入了互联网的内部。互联网的入口线路称为接入网。一般来说，我们可以用电话线、ISDN、ADSL、有线电视、光线、专线等多种通信线路来接入互联网，这些通信线路统称为接入网。接入网连接到签约的网络运营商，并接入被称为接入点（Point ofPresence, PoP）的设备。接入点的实体是一台专为运营商设计的路由器，我们可以把它理解为离你家最近的邮局。从各个邮筒中收集来的信件会在邮局进行分拣，然后被送往全国甚至全世界，互联网也是一样，网络包首先通过接入网被发送到接入点，然后再从这里被发送到全国甚至全世界。接入点的后面就是互联网的骨干部分了。在骨干网中存在很多运营商和大量的路由器，这些路由器相互连接，组成一张巨大的网，而我们的网络包就在其中经过若干路由器的接力，最终被发送到目标 Web 服务器上。它的基本原理和家庭、公司中的路由器是相同的。也就是说，无论是在互联网中，还是在家庭、公司的局域网中，包都是以相同的方式传输的，这也是互联网的一大特征。</li>
<li>防火墙、缓存服务器： 通过骨干网之后，网络包最终到达了 Web 服务器所在的局域网中。接着，它会遇到防火墙，防火墙会对进入的包进行检查。它会检查所有进入的包，看看有没有危险的包混在里面。检查完之后，网络包接下来可能还会遇到缓存服务器。网页数据中有一部分是可以重复利用的，这些可以重复利用的数据就被保存在缓存服务器中。如果要访问的网页数据正好在缓存服务器中能够找到，那么就可以不用劳烦 Web 服务器，直接从缓存服务器读出数据。此外，在大型网站中，可能还会配备将消息分布到多台 Web 服务器上的负载均衡器，还有可能会使用通过分布在整个互联网中的缓存服务器来分发内容的服务。经过这些机制之后，网络包才会到达 Web 服务器。</li>
<li>Web 服务器： 当网络包到达 Web 服务器后，数据会被解包并还原为原始的请求消息，然后交给 Web 服务器程序。和客户端一样，这个操作也是由操作系统中的协议栈（网络控制软件）来完成的。接下来，Web 服务器程序分析请求消息的含义，并按照其中的指示将数据装入响应消息中，然后发回给客户端。响应消息回到客户端的过程和之前我们介绍的过程正好相反。当响应到达客户端之后，浏览器会从中读取出网页的数据并在屏幕上显示出来。到这里，访问 Web 服务器的一系列操作就全部完成了。</li>
</ol>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><h3 id="浏览器生成消息"><a href="#浏览器生成消息" class="headerlink" title="浏览器生成消息"></a>浏览器生成消息</h3><h4 id="HTTP-消息格式"><a href="#HTTP-消息格式" class="headerlink" title="HTTP 消息格式"></a>HTTP 消息格式</h4><ul>
<li>请求行，请求头，请求体</li>
</ul>
<h4 id="DNS-查询"><a href="#DNS-查询" class="headerlink" title="DNS 查询"></a>DNS 查询</h4><ul>
<li>域名的层次结构</li>
<li>递归与迭代查询</li>
<li>使用 UDP</li>
<li>dig、nslookup、host、whois 命令</li>
</ul>
<pre><code>域名解析过程:

1. 操作系统会先检查自己本地的 hosts 文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。
2.如果 hosts 里没有这个域名的映射，则查找本地 DNS 解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。
3.如果 hosts 与本地 DNS 解析器缓存都没有相应的网址映射关系，首先会找 TCP/IP 参数中设置的首选 DNS 服务器，在此我们叫它本地 DNS 服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。
4.如果要查询的域名，不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析，此解析不具有权威性。
5.如果本地 DNS 服务器本地区域文件与缓存解析都失效，则根据本地 DNS 服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地 DNS 就把请求发至 “根 DNS 服务器”，“根 DNS 服务器”收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个 IP。本地 DNS 服务器收到 IP 信息后，将会联系负责.com 域的这台服务器。这台负责.com 域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com 域的下一级 DNS 服务器地址(qq.com)给本地 DNS 服务器。当本地 DNS 服务器收到这个地址后，就会找 qq.com 域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。
6.如果用的是转发模式，此 DNS 服务器就会把请求转发至上一级 DNS 服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上上级，以此循环。

不管是本地 DNS 服务器用是是转发，还是根提示，最后都是把结果返回给本地 DNS 服务器，由此 DNS 服务器再返回给客户机。

递归查询与迭代查询:
一、主机向本地域名服务器的查询一般都是采用递归查询。

所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。

二、本地域名服务器向根域名服务器的查询的迭代查询。

迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。
</code></pre>
<h3 id="协议栈与网卡"><a href="#协议栈与网卡" class="headerlink" title="协议栈与网卡"></a>协议栈与网卡</h3><h4 id="协议栈通过-TCP-协议收发数据分为-4-个阶段。"><a href="#协议栈通过-TCP-协议收发数据分为-4-个阶段。" class="headerlink" title="协议栈通过 TCP 协议收发数据分为 4 个阶段。"></a>协议栈通过 TCP 协议收发数据分为 4 个阶段。</h4><ol>
<li>创建套接字</li>
<li>连接服务器</li>
<li>收发数据</li>
<li>断开并删除套接字</li>
</ol>
<ul>
<li><p>套接字： 在协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的控制信息，例如通信对象的 IP 地址、端口号、通信操作的进行状态等。套接字就只是一个概念而已，并不存在实体，如果一定要赋予它一个实体，我们可以说这些控制信息就是套接字的实体，或者说存放控制信息的内存空间就是套接字的实体。协议栈在执行操作时需要参阅这些控制信息。例如，在发送数据时，需要看一看套接字中的通信对象 IP 地址和端口号，以便向指定的 IP 地址和端口发送数据。在发送数据之后，协议栈需要等待对方返回收到数据的响应信息，但数据也可能在中途丢失，永远也等不到对方的响应。在这样的情况下，我们不能一直等下去，需要在等待一定时间之后重新发送丢失的数据，这就需要协议栈能够知道执行发送数据操作后过了多长时间。为此，套接字中必须要记录是否已经收到响应，以及发送数据后经过了多长时间，才能根据这些信息按照需要执行重发操作。上面说的只是其中一个例子。套接字中记录了用于控制通信操作的各种控制信息，协议栈则需要根据这些信息判断下一步的行动，这就是套接字的作用。协议栈是根据套接字中记录的控制信息来工作的。</p>
</li>
<li><p>连接套接字：协议栈会将本地的套接字与服务器的套接字进行连接。这里的“连接”到底如何理解？连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作。套接字刚刚创建完成的时候，里面并没有存放任何数据，也不知道通信的对象是谁。在这个状态下，即便应用程序要求发送数据，协议栈也不知道数据应该发送给谁。因此，我们需要把服务器的 IP 地址和端口号等信息告知协议栈，这是连接操作的目的之一。同时，我们需要让客户端向服务器告知必要的信息，比如“我想和你开始通信，我的 IP 地址是 xxx.xxx. xxx.xxx，端口号是 yyyy。”可见，客户端向服务器传达开始通信的请求，也是连接操作的目的之一。</p>
</li>
</ul>
<pre><code>注： 使用 netstat 命令可以显示系统中的套接字。

Internet domain socket states(Socket的状态及释义，使用 man netstat 命令获取):

CLOSED:  The socket is not in use.

LISTEN:  The socket is listening for incoming connections.  Unconnected
listening sockets like these are only displayed when using the -a option.

SYN_SENT:  The socket is actively trying to establish a connection to a
remote peer.

SYN_RCVD:  The socket has passively received a connection request from a
remote peer.

ESTABLISHED:  The socket has an established connection between a local
application and a remote peer.

CLOSE_WAIT:  The socket connection has been closed by the remote peer,
and the system is waiting for the local application to close its half of
the connection.

LAST_ACK:  The socket connection has been closed by the remote peer, the
local application has closed its half of the connection, and the system
is waiting for the remote peer to acknowledge the close.

FIN_WAIT_1:  The socket connection has been closed by the local
application, the remote peer has not yet acknowledged the close, and the
system is waiting for it to close its half of the connection.

FIN_WAIT_2:  The socket connection has been closed by the local
application, the remote peer has acknowledged the close, and the system
is waiting for it to close its half of the connection.

CLOSING:  The socket connection has been closed by the local application
and the remote peer simultaneously, and the remote peer has not yet
acknowledged the close attempt of the local application.

TIME_WAIT:  The socket connection has been closed by the local
application, the remote peer has closed its half of the connection, and
the system is waiting to be sure that the remote peer received the last
acknowledgement.
</code></pre>
<ul>
<li>TCP 连接三次握手</li>
</ul>
<p>当 TCP 头部创建好之后，接下来 TCP 模块会将信息传递给 IP 模块并委托它进行发送。IP 模块执行网络包发送操作后，网络包就会通过网络到达服务器，然后服务器上的 IP 模块会将接收到的数据传递给 TCP 模块，服务器的 TCP 模块根据 TCP 头部中的信息找到端口号对应的套接字，也就是说，从处于等待连接状态的套接字中找到与 TCP 头部中记录的端口号相同的套接字就可以了。当找到对应的套接字之后，套接字中会写入相应的信息，并将状态改为正在连接。上述操作完成后，服务器的 TCP 模块会返回响应，这个过程和客户端一样，需要在 TCP 头部中设置发送方和接收方端口号以及 SYN 比特。此外，在返回响应时还需要将 ACK 控制位设为 1，这表示已经接收到相应的网络包。网络中经常会发生错误，网络包也会发生丢失，因此双方在通信时必须相互确认网络包是否已经送达，而设置 ACK 比特就是用来进行这一确认的。接下来，服务器 TCP 模块会将 TCP 头部传递给 IP 模块，并委托 IP 模块向客户端返回响应。</p>
<p>然后，网络包就会返回到客户端，通过 IP 模块到达 TCP 模块，并通过 TCP 头部的信息确认连接服务器的操作是否成功。如果 SYN 为 1 则表示连接成功，这时会向套接字中写入服务器的 IP 地址、端口号等信息，同时还会将状态改为连接完毕。到这里，客户端的操作就已经完成，但其实还剩下最后一个步骤。刚才服务器返回响应时将 ACK 比特设置为 1，相应地，客户端也需要将 ACK 比特设置为 1 并发回服务器，告诉服务器刚才的响应包已经收到。当这个服务器收到这个返回包之后，连接操作才算全部完成。现在，套接字就已经进入随时可以收发数据的状态了，大家可以认为这时有一根管子把两个套接字连接了起来。当然，实际上并不存在这么一根管子，不过这样想比较容易理解，网络业界也习惯这样来描述。这根管子，我们称之为连接。只要数据传输过程在持续，也就是在调用 close 断开之前，连接是一直存在的。</p>
<p>建立连接之后，协议栈的连接操作就结束了，也就是说 connect 已经执行完毕，控制流程被交回到应用程序。</p>
<ul>
<li>数据收发： 协议栈并不是一收到数据就马上发送出去，而是会将数据存放在内部的发送缓冲区中，并等待应用程序的下一段数据。至于要积累多少数据才能发送，不同种类和版本的操作系统会有所不同，不能一概而论，但都是根据下面几个要素来判断的。第一个判断要素是每个网络包能容纳的数据长度，协议栈会根据一个叫作 MTU 的参数来进行判断。MTU 表示一个网络包的最大长度，在以太网中一般是 1500 字节。MTU 是包含头部的总长度，因此需要从 MTU 减去头部的长度，然后得到的长度就是一个网络包中所能容纳的最大数据长度，这一长度叫作 MSS。当从应用程序收到的数据长度超过或者接近 MSS 时再发送出去，就可以避免发送大量小包的问题了。另一个判断要素是时间。当应用程序发送数据的频率不高的时候，如果每次都等到长度接近 MSS 时再发送，可能会因为等待时间太长而造成发送延迟，这种情况下，即便缓冲区中的数据长度没有达到 MSS，也应该果断发送出去。为此，协议栈的内部有一个计时器，当经过一定时间之后，就会把网络包发送出去。判断要素就是这两个，但它们其实是互相矛盾的。如果长度优先，那么网络的效率会提高，但可能会因为等待填满缓冲区而产生延迟；相反地，如果时间优先，那么延迟时间会变少，但又会降低网络的效率。因此，在进行发送操作时需要综合考虑这两个要素以达到平衡。不过，TCP 协议规格中并没有告诉我们怎样才能平衡，因此实际如何判断是由协议栈的开发者来决定的，也正是由于这个原因，不同种类和版本的操作系统在相关操作上也就存在差异。正如前面所说，如果仅靠协议栈来判断发送的时机可能会带来一些问题，因此协议栈也给应用程序保留了控制发送时机的余地。应用程序在发送数据时可以指定一些选项，比如如果指定“不等待填满缓冲区直接发送”，则协议栈就会按照要求直接发送数据(例如 nodejs 中可以通过 socket.setNoDelay 方法来控制是否延迟发送数据)。像浏览器这种会话型的应用程序在向服务器发送数据时，等待填满缓冲区导致延迟会产生很大影响，因此一般会使用直接发送的选项。</li>
</ul>
<p>待发送的数据长度如果超出 MSS，TCP 会按照网络包的大小进行拆分，然后每一段放在一个网络包中发送。TCP 模块在拆分数据时，会先算好每一块数据相当于从头开始的第几个字节，接下来在发送这一块数据时，将算好的字节数写在 TCP 头部中，“序号”字段就是派在这个用场上的。发送数据的长度也需要告知接收方，不过这个并不是放在 TCP 头部里面的，因为用整个网络包的长度减去头部的长度就可以得到数据的长度，所以接收方可以用这种方法来进行计算。有了上面两个数值，我们就可以知道发送的数据是从第几个字节开始，长度是多少了。如果确认没有遗漏，接收方会将到目前为止接收到的数据长度加起来，计算出一共已经收到了多少个字节，然后将这个数值写入 TCP 头部的 ACK 号中发送给发送方。简单来说，发送方说的是“现在发送的是从第 ×× 字节开始的部分，一共有 ×× 字节哦！”而接收方则回复说，“到第 ×× 字节之前的数据我已经都收到了哦！”这个返回 ACK 号的操作被称为确认响应，通过这样的方式，发送方就能够确认对方到底收到了多少数据。在实际的通信中，序号并不是从 1 开始的，而是需要用随机数计算出一个初始值，这是因为如果序号都从 1 开始，通信过程就会非常容易预测，有人会利用这一点来发动攻击。但是如果初始值是随机的，那么对方就搞不清楚序号到底是从多少开始计算的，因此需要在开始收发数据之前将初始值告知通信对象。大家应该还记得在我们刚才讲过的连接过程中，有一个将 SYN 控制位设为 1 并发送给服务器的操作，就是在这一步将序号的初始值告知对方的。实际上，在将 SYN 设为 1 的同时，还需要同时设置序号字段的值，而这里的值就代表序号的初始值（三次握手）。客户端和服务器双方都需要各自计算序号，因此双方需要在连接过程中互相告知自己计算的序号初始值。</p>
<ul>
<li><p>拥塞控制</p>
</li>
<li><p>滑动窗口： 每发送一个包就等待一个 ACK 号的方式是最简单也最容易理解的，但在等待 ACK 号的这段时间中，如果什么都不做那实在太浪费了。为了减少这样的浪费，TCP 采用滑动窗口方式来管理数据发送和 ACK 号的操作。所谓滑动窗口，就是在发送一个包之后，不等待 ACK 号返回，而是直接发送后续的一系列包。这样一来，等待 ACK 号的这段时间就被有效利用起来了。</p>
</li>
</ul>
<h4 id="IP-与以太包收发"><a href="#IP-与以太包收发" class="headerlink" title="IP 与以太包收发"></a>IP 与以太包收发</h4><p>在互联网上传送数据时，数据会被切分成一个一个的网络包，而将网络包发送给通信对象的操作就是由 IP 来负责的。此外，IP 中还包括 ICMP 协议和 ARP 协议。ICMP 用于告知网络包传送过程中产生的错误以及各种控制消息，ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。</p>
<h4 id="UDP-协议收发数据"><a href="#UDP-协议收发数据" class="headerlink" title="UDP 协议收发数据"></a>UDP 协议收发数据</h4><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/36502282">彻底揭开“从 URL 到页面展现发生了什么”的秘密</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2016/06/dns.html">DNS 原理入门-阮一峰！！！</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
