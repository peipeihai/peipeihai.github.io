<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>javascript中的代理与反射</title>
    <url>/2021/06/28/javascript/javascript%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>ECMAScript6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<h1 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h1><h2 id="创建代理"><a href="#创建代理" class="headerlink" title="创建代理"></a>创建代理</h2><p>代理是使用 Proxy 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。</p>
<pre><code>const target = &#123; id: &#39;target&#39; &#125;;
const handler = &#123;&#125;;

const proxy = new Proxy(target, handler);

console.log(target.id); // target
console.log(proxy.id); // target

// 给目标赋值也会反映到代理上，两者引用的是同一个对象
target.id = &#39;foo&#39;;
console.log(target.id); // foo
console.log(proxy.id); // foo

// 给代理赋值同样也会反映到目标上
proxy.id = &#39;bar&#39;;
console.log(target.id); // bar
console.log(proxy.id); // bar

console.log(target.hasOwnProperty(&#39;id&#39;)); // true
console.log(proxy.hasOwnProperty(&#39;id&#39;)); // true
</code></pre>
<h2 id="定义捕获器"><a href="#定义捕获器" class="headerlink" title="定义捕获器"></a>定义捕获器</h2><p>使用代理的主要目的是可以定义捕获器（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。</p>
<pre><code>注： 捕获器（trap）是从操作系统中借用的概念。在操作系统中，捕获器是程序流中的一个同步中断，可以暂停程序流，转而执行一段子例程，之后再返回原始程序流。
</code></pre>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const handler = &#123;
  get() &#123;
    return &#39;handler override&#39;;
  &#125;,
&#125;;
const proxy = new Proxy(target, handler);

// 注意，只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正常的行为。
console.log(proxy.foo); // handler override
console.log(target.foo); // bar
</code></pre>
<h2 id="捕获器参数和反射-API"><a href="#捕获器参数和反射-API" class="headerlink" title="捕获器参数和反射 API"></a>捕获器参数和反射 API</h2><p>所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如，get()捕获器会接收到目标对象、要查询的属性和代理对象三个参数。</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const handler = &#123;
  get(trapTarget, property, receiver) &#123;
    console.log(target === trapTarget);
    console.log(property);
    console.log(receiver === proxy);

    // 有了这些参数，就可以重建被捕获方法的原始行为
    return trapTarget[property];
  &#125;,
&#125;;
const proxy = new Proxy(target, handler);
console.log(proxy.foo);
// true
// foo
// true
// bar
</code></pre>
<p>所有捕获器都可以基于自己的参数重建原始操作，但并非所有捕获器行为都像 get()那么简单。因此，通过手动写码如法炮制的想法是不现实的。实际上，开发者并不需要手动重建原始行为，而是可以通过调用全局 Reflect 对象上（封装了原始行为）的同名方法来轻松重建。处理程序对象中所有可以捕获的方法都有对应的反射（Reflect）API 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const handler = &#123;
  get() &#123;
    return Reflect.get(...arguments);
  &#125;,
  // 甚至可以使用更简洁的写法
  // get: Reflect.get,
&#125;;
const proxy = new Proxy(target, handler);
console.log(proxy.foo);
</code></pre>
<p>使用代理对原对象的访问进行修饰：</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const handler = &#123;
  get(trapTarget, property, receiver) &#123;
    let propertyDecoration = &#39;&#39;;
    if (property === &#39;foo&#39;) &#123;
      propertyDecoration = &#39;!!!&#39;;
    &#125;
    return Reflect.get(target, property, receiver) + propertyDecoration;
  &#125;,
&#125;;
const proxy = new Proxy(target, handler);
console.log(proxy.foo); // bar!!!
</code></pre>
<h2 id="可撤销代理"><a href="#可撤销代理" class="headerlink" title="可撤销代理"></a>可撤销代理</h2><p>有时候可能需要中断代理对象与目标对象之间的联系。对于使用 new Proxy()创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。Proxy 也暴露了 revocable()方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数（revoke()）是幂等的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出 TypeError。</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const handler = &#123;
  get(trapTarget, property, receiver) &#123;
    let propertyDecoration = &#39;&#39;;
    if (property === &#39;foo&#39;) &#123;
      propertyDecoration = &#39;!!!&#39;;
    &#125;
    return Reflect.get(target, property, receiver) + propertyDecoration;
  &#125;,
&#125;;
const &#123; proxy, revoke &#125; = Proxy.revocable(target, handler);
console.log(proxy.foo); // bar!!!

// 撤销代理
revoke();
console.log(proxy.foo); // TypeError: Cannot perform &#39;get&#39; on a proxy that has been revoked
</code></pre>
<h2 id="多层代理"><a href="#多层代理" class="headerlink" title="多层代理"></a>多层代理</h2><p>代理可以拦截反射 API 的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网。</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const firstProxy = new Proxy(target, &#123;
  get() &#123;
    console.log(&#39;first proxy&#39;);
    return Reflect.get(...arguments);
  &#125;,
&#125;);
const secondProxy = new Proxy(firstProxy, &#123;
  get() &#123;
    console.log(&#39;second proxy&#39;);
    return Reflect.get(...arguments);
  &#125;,
&#125;);
console.log(secondProxy.foo);
// second proxy
// first proxy
// bar
</code></pre>
<h2 id="代理捕获器与反射方法"><a href="#代理捕获器与反射方法" class="headerlink" title="代理捕获器与反射方法"></a>代理捕获器与反射方法</h2><p>代理可以捕获 13 种不同的基本操作。这些操作有各自不同的反射 API 方法、参数、关联 ECMAScript 操作和不变式。</p>
<ul>
<li>get()</li>
<li>set()</li>
<li>has()</li>
<li>defineProperty()</li>
<li>getOwnPropertyDescriptor()</li>
<li>deleteProperty()</li>
<li>ownKeys()</li>
<li>getPrototypeOf()</li>
<li>setPrototypeOf()</li>
<li>isExtensible()</li>
<li>preventExtensions()</li>
<li>apply()</li>
<li>construct()</li>
</ul>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>使用代理可以在代码中实现一些有用的编程模式。</p>
<h2 id="1-跟踪属性访问"><a href="#1-跟踪属性访问" class="headerlink" title="1. 跟踪属性访问"></a>1. 跟踪属性访问</h2><p>通过捕获 get、set 和 has 等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过。</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const proxy = new Proxy(target, &#123;
  get(target, propertyKey, receiver) &#123;
    console.log(`getting property: $&#123;propertyKey&#125;`);
    return Reflect.get(...arguments);
  &#125;,
  set(target, propertyKey, value, receiver) &#123;
    console.log(`setting property: $&#123;propertyKey&#125;, with value: $&#123;value&#125;`);
    return Reflect.set(...arguments);
  &#125;,
&#125;);
proxy.foo; // getting property: foo
proxy.foo = &#39;hello&#39;; // setting property: foo, with value: hello
</code></pre>
<h2 id="2-隐藏属性"><a href="#2-隐藏属性" class="headerlink" title="2. 隐藏属性"></a>2. 隐藏属性</h2><p>实现很简单，如果不想对外提供某个属性的访问，只需要在 get 捕获器返回 undefined 即可。</p>
<h2 id="3-属性验证"><a href="#3-属性验证" class="headerlink" title="3. 属性验证"></a>3. 属性验证</h2><p>所有赋值操作都会触发 set() 捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值。</p>
<h2 id="4-函数与构造函数参数验证"><a href="#4-函数与构造函数参数验证" class="headerlink" title="4. 函数与构造函数参数验证"></a>4. 函数与构造函数参数验证</h2><p>跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。</p>
<p>使用 apply 捕获器代理函数，执行参数检查：</p>
<pre><code>function sum(...nums) &#123;
  return nums.reduce((a, b) =&gt; a + b, 0);
&#125;

const sumProxy = new Proxy(sum, &#123;
  apply(target, thisArg, argumentsList) &#123;
    for (let item of argumentsList) &#123;
      if (typeof item !== &#39;number&#39;) &#123;
        throw new Error(&#39;arguments must be numbers&#39;);
      &#125;
    &#125;
    return Reflect.apply(...arguments);
  &#125;,
&#125;);

console.log(sumProxy(1, 2, 3, 4)); // 10
console.log(sumProxy(1, 2, 3, 4, &#39;hello&#39;)); // Error: arguments must be numbers
</code></pre>
<p>使用 contruct 捕获器代理类，检查构造器参数：</p>
<pre><code>class Person &#123;
  constructor(name) &#123;
    this.name = name;
  &#125;
&#125;

const PersonProxy = new Proxy(Person, &#123;
  construct(target, argumentsList, newTarget) &#123;
    if (argumentsList[0] === undefined) &#123;
      throw new Error(&#39;Person cannot be inited with `name` arg&#39;);
    &#125; else &#123;
      return Reflect.construct(...arguments);
    &#125;
  &#125;,
&#125;);

new PersonProxy(&#39;john&#39;); // ok
new PersonProxy(); // Error: Person cannot be inited with `name` arg
</code></pre>
<h2 id="5-数据绑定与可观察对象"><a href="#5-数据绑定与可观察对象" class="headerlink" title="5. 数据绑定与可观察对象"></a>5. 数据绑定与可观察对象</h2><p>通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作。比如，可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合中。</p>
<pre><code>const people = [];

class Person &#123;
  constructor(name) &#123;
    this.name = name;
  &#125;
&#125;

const PersonProxy = new Proxy(Person, &#123;
  construct() &#123;
    const newTarget = Reflect.construct(...arguments);
    people.push(newTarget);
    return newTarget;
  &#125;,
&#125;);

new PersonProxy(&#39;john&#39;);
new PersonProxy(&#39;jack&#39;);

console.log(people); // [ Person &#123; name: &#39;john&#39; &#125;, Person &#123; name: &#39;jack&#39; &#125; ]
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>代理是 ECMAScript 6 新增的令人兴奋和动态十足的新特性。尽管不支持向后兼容，但它开辟出了一片前所未有的 JavaScript 元编程及抽象的新天地。</p>
<p>从宏观上看，代理是真实 JavaScript 对象的透明抽象层。代理可以定义包含捕获器的处理程序对象，而这些捕获器可以拦截绝大部分 JavaScript 的基本操作和方法。在这个捕获器处理程序中，可以修改任何基本操作的行为，当然前提是遵从捕获器不变式。</p>
<p>与代理如影随形的反射 API，则封装了一整套与捕获器拦截的操作相对应的方法。可以把反射 API 看作一套基本操作，这些操作是绝大部分 JavaScript 对象 API 的基础。</p>
<p>代理的应用场景是不可限量的。开发者使用它可以创建出各种编码模式，比如（但远远不限于）跟踪属性访问、隐藏属性、阻止修改或删除属性、函数参数验证、构造函数参数验证、数据绑定，以及可观察对象。</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>代理</tag>
        <tag>Proxy</tag>
        <tag>反射</tag>
        <tag>Reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript中的垃圾回收</title>
    <url>/2021/06/28/javascript/javascript%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<p>在浏览器的发展史上，用到过两种主要的标记策略：标记清理和引用计数。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<h2 id="标记清理"><a href="#标记清理" class="headerlink" title="标记清理"></a>标记清理</h2><p>JavaScript 最常用的垃圾回收策略是标记清理（mark-and-sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。</p>
<p>给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。<br>垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。</p>
<p>到了 2008 年，IE、Firefox、Opera、Chrome 和 Safari 都在自己的 JavaScript 实现中采用标记清理（或其变体），只是在运行垃圾回收的频率上有所差异。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>另一种没那么常用的垃圾回收策略是引用计数（reference counting）。其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。<br>如果同一个值又被赋给另一个变量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。<br>垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存。<br>引用计数最早由 Netscape Navigator 3.0 采用，但很快就遇到了严重的问题：循环引用。所谓循环引用，就是对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A。<br>为避免类似的循环引用问题，应该在确保不使用的情况下切断原生 JavaScript 对象与 DOM 元素之间的连接。</p>
<p>比如，通过以下代码可以清除前面的例子中建立的循环引用：</p>
<pre><code>myObject.element = null;￼
element.someObject = null;
</code></pre>
<p>把变量设置为 null 实际上会切断变量与其之前引用值之间的关系。当下次垃圾回收程序运行时，这些值就会被删除，内存也会被回收。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>写得不好的 JavaScript 可能出现难以察觉且有害的内存泄漏问题。在内存有限的设备上，或者在函数会被调用很多次的情况下，内存泄漏可能是个大问题。JavaScript 中的内存泄漏大部分是由不合理的引用导致的。</p>
<ol>
<li>意外声明全局变量是最常见但也最容易修复的内存泄漏问题。</li>
<li>定时器也可能会悄悄地导致内存泄漏。下面的代码中，定时器的回调通过闭包引用了外部变量：</li>
</ol>
<pre><code>let name = &#39;Jake&#39;;￼
setInterval(() =&gt; &#123;￼ console.log(name);￼ &#125;, 100);
</code></pre>
<p>只要定时器一直运行，回调函数中引用的 name 就会一直占用内存。</p>
<ol start="3">
<li>使用 JavaScript 闭包很容易在不知不觉间造成内存泄漏。请看下面的例子：</li>
</ol>
<pre><code>let outer = function() &#123;￼
    let name = &#39;Jake&#39;;￼
    return function() &#123;￼
        return name;
￼ &#125;;￼
&#125;;
</code></pre>
<p>调用 outer()会导致分配给 name 的内存被泄漏。以上代码执行后创建了一个内部闭包，只要返回的函数存在就不能清理 name，因为闭包一直在引用着它。假如 name 的内容很大（不止是一个小字符串），那可能就是个大问题了。</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>江雪</title>
    <url>/2021/06/28/%E8%AF%97%E8%AF%8D/%E6%B1%9F%E9%9B%AA/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>诗词</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>柳宗元</tag>
      </tags>
  </entry>
</search>
