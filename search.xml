<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>javascript中的代理与反射</title>
    <url>/2021/06/28/javascript/javascript%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>ECMAScript6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<h1 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h1><h2 id="创建代理"><a href="#创建代理" class="headerlink" title="创建代理"></a>创建代理</h2><p>代理是使用 Proxy 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。</p>
<pre><code>const target = &#123; id: &#39;target&#39; &#125;;
const handler = &#123;&#125;;

const proxy = new Proxy(target, handler);

console.log(target.id); // target
console.log(proxy.id); // target

// 给目标赋值也会反映到代理上，两者引用的是同一个对象
target.id = &#39;foo&#39;;
console.log(target.id); // foo
console.log(proxy.id); // foo

// 给代理赋值同样也会反映到目标上
proxy.id = &#39;bar&#39;;
console.log(target.id); // bar
console.log(proxy.id); // bar

console.log(target.hasOwnProperty(&#39;id&#39;)); // true
console.log(proxy.hasOwnProperty(&#39;id&#39;)); // true
</code></pre>
<h2 id="定义捕获器"><a href="#定义捕获器" class="headerlink" title="定义捕获器"></a>定义捕获器</h2><p>使用代理的主要目的是可以定义捕获器（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。</p>
<pre><code>注： 捕获器（trap）是从操作系统中借用的概念。在操作系统中，捕获器是程序流中的一个同步中断，可以暂停程序流，转而执行一段子例程，之后再返回原始程序流。
</code></pre>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const handler = &#123;
  get() &#123;
    return &#39;handler override&#39;;
  &#125;,
&#125;;
const proxy = new Proxy(target, handler);

// 注意，只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正常的行为。
console.log(proxy.foo); // handler override
console.log(target.foo); // bar
</code></pre>
<h2 id="捕获器参数和反射-API"><a href="#捕获器参数和反射-API" class="headerlink" title="捕获器参数和反射 API"></a>捕获器参数和反射 API</h2><p>所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如，get()捕获器会接收到目标对象、要查询的属性和代理对象三个参数。</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const handler = &#123;
  get(trapTarget, property, receiver) &#123;
    console.log(target === trapTarget);
    console.log(property);
    console.log(receiver === proxy);

    // 有了这些参数，就可以重建被捕获方法的原始行为
    return trapTarget[property];
  &#125;,
&#125;;
const proxy = new Proxy(target, handler);
console.log(proxy.foo);
// true
// foo
// true
// bar
</code></pre>
<p>所有捕获器都可以基于自己的参数重建原始操作，但并非所有捕获器行为都像 get()那么简单。因此，通过手动写码如法炮制的想法是不现实的。实际上，开发者并不需要手动重建原始行为，而是可以通过调用全局 Reflect 对象上（封装了原始行为）的同名方法来轻松重建。处理程序对象中所有可以捕获的方法都有对应的反射（Reflect）API 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const handler = &#123;
  get() &#123;
    return Reflect.get(...arguments);
  &#125;,
  // 甚至可以使用更简洁的写法
  // get: Reflect.get,
&#125;;
const proxy = new Proxy(target, handler);
console.log(proxy.foo);
</code></pre>
<p>使用代理对原对象的访问进行修饰：</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const handler = &#123;
  get(trapTarget, property, receiver) &#123;
    let propertyDecoration = &#39;&#39;;
    if (property === &#39;foo&#39;) &#123;
      propertyDecoration = &#39;!!!&#39;;
    &#125;
    return Reflect.get(target, property, receiver) + propertyDecoration;
  &#125;,
&#125;;
const proxy = new Proxy(target, handler);
console.log(proxy.foo); // bar!!!
</code></pre>
<h2 id="可撤销代理"><a href="#可撤销代理" class="headerlink" title="可撤销代理"></a>可撤销代理</h2><p>有时候可能需要中断代理对象与目标对象之间的联系。对于使用 new Proxy()创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。Proxy 也暴露了 revocable()方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数（revoke()）是幂等的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出 TypeError。</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const handler = &#123;
  get(trapTarget, property, receiver) &#123;
    let propertyDecoration = &#39;&#39;;
    if (property === &#39;foo&#39;) &#123;
      propertyDecoration = &#39;!!!&#39;;
    &#125;
    return Reflect.get(target, property, receiver) + propertyDecoration;
  &#125;,
&#125;;
const &#123; proxy, revoke &#125; = Proxy.revocable(target, handler);
console.log(proxy.foo); // bar!!!

// 撤销代理
revoke();
console.log(proxy.foo); // TypeError: Cannot perform &#39;get&#39; on a proxy that has been revoked
</code></pre>
<h2 id="多层代理"><a href="#多层代理" class="headerlink" title="多层代理"></a>多层代理</h2><p>代理可以拦截反射 API 的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网。</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const firstProxy = new Proxy(target, &#123;
  get() &#123;
    console.log(&#39;first proxy&#39;);
    return Reflect.get(...arguments);
  &#125;,
&#125;);
const secondProxy = new Proxy(firstProxy, &#123;
  get() &#123;
    console.log(&#39;second proxy&#39;);
    return Reflect.get(...arguments);
  &#125;,
&#125;);
console.log(secondProxy.foo);
// second proxy
// first proxy
// bar
</code></pre>
<h2 id="代理捕获器与反射方法"><a href="#代理捕获器与反射方法" class="headerlink" title="代理捕获器与反射方法"></a>代理捕获器与反射方法</h2><p>代理可以捕获 13 种不同的基本操作。这些操作有各自不同的反射 API 方法、参数、关联 ECMAScript 操作和不变式。</p>
<ul>
<li>get()</li>
<li>set()</li>
<li>has()</li>
<li>defineProperty()</li>
<li>getOwnPropertyDescriptor()</li>
<li>deleteProperty()</li>
<li>ownKeys()</li>
<li>getPrototypeOf()</li>
<li>setPrototypeOf()</li>
<li>isExtensible()</li>
<li>preventExtensions()</li>
<li>apply()</li>
<li>construct()</li>
</ul>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>使用代理可以在代码中实现一些有用的编程模式。</p>
<h2 id="1-跟踪属性访问"><a href="#1-跟踪属性访问" class="headerlink" title="1. 跟踪属性访问"></a>1. 跟踪属性访问</h2><p>通过捕获 get、set 和 has 等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过。</p>
<pre><code>const target = &#123; foo: &#39;bar&#39; &#125;;
const proxy = new Proxy(target, &#123;
  get(target, propertyKey, receiver) &#123;
    console.log(`getting property: $&#123;propertyKey&#125;`);
    return Reflect.get(...arguments);
  &#125;,
  set(target, propertyKey, value, receiver) &#123;
    console.log(`setting property: $&#123;propertyKey&#125;, with value: $&#123;value&#125;`);
    return Reflect.set(...arguments);
  &#125;,
&#125;);
proxy.foo; // getting property: foo
proxy.foo = &#39;hello&#39;; // setting property: foo, with value: hello
</code></pre>
<h2 id="2-隐藏属性"><a href="#2-隐藏属性" class="headerlink" title="2. 隐藏属性"></a>2. 隐藏属性</h2><p>实现很简单，如果不想对外提供某个属性的访问，只需要在 get 捕获器返回 undefined 即可。</p>
<h2 id="3-属性验证"><a href="#3-属性验证" class="headerlink" title="3. 属性验证"></a>3. 属性验证</h2><p>所有赋值操作都会触发 set() 捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值。</p>
<h2 id="4-函数与构造函数参数验证"><a href="#4-函数与构造函数参数验证" class="headerlink" title="4. 函数与构造函数参数验证"></a>4. 函数与构造函数参数验证</h2><p>跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。</p>
<p>使用 apply 捕获器代理函数，执行参数检查：</p>
<pre><code>function sum(...nums) &#123;
  return nums.reduce((a, b) =&gt; a + b, 0);
&#125;

const sumProxy = new Proxy(sum, &#123;
  apply(target, thisArg, argumentsList) &#123;
    for (let item of argumentsList) &#123;
      if (typeof item !== &#39;number&#39;) &#123;
        throw new Error(&#39;arguments must be numbers&#39;);
      &#125;
    &#125;
    return Reflect.apply(...arguments);
  &#125;,
&#125;);

console.log(sumProxy(1, 2, 3, 4)); // 10
console.log(sumProxy(1, 2, 3, 4, &#39;hello&#39;)); // Error: arguments must be numbers
</code></pre>
<p>使用 contruct 捕获器代理类，检查构造器参数：</p>
<pre><code>class Person &#123;
  constructor(name) &#123;
    this.name = name;
  &#125;
&#125;

const PersonProxy = new Proxy(Person, &#123;
  construct(target, argumentsList, newTarget) &#123;
    if (argumentsList[0] === undefined) &#123;
      throw new Error(&#39;Person cannot be inited with `name` arg&#39;);
    &#125; else &#123;
      return Reflect.construct(...arguments);
    &#125;
  &#125;,
&#125;);

new PersonProxy(&#39;john&#39;); // ok
new PersonProxy(); // Error: Person cannot be inited with `name` arg
</code></pre>
<h2 id="5-数据绑定与可观察对象"><a href="#5-数据绑定与可观察对象" class="headerlink" title="5. 数据绑定与可观察对象"></a>5. 数据绑定与可观察对象</h2><p>通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作。比如，可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合中。</p>
<pre><code>const people = [];

class Person &#123;
  constructor(name) &#123;
    this.name = name;
  &#125;
&#125;

const PersonProxy = new Proxy(Person, &#123;
  construct() &#123;
    const newTarget = Reflect.construct(...arguments);
    people.push(newTarget);
    return newTarget;
  &#125;,
&#125;);

new PersonProxy(&#39;john&#39;);
new PersonProxy(&#39;jack&#39;);

console.log(people); // [ Person &#123; name: &#39;john&#39; &#125;, Person &#123; name: &#39;jack&#39; &#125; ]
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>代理是 ECMAScript 6 新增的令人兴奋和动态十足的新特性。尽管不支持向后兼容，但它开辟出了一片前所未有的 JavaScript 元编程及抽象的新天地。</p>
<p>从宏观上看，代理是真实 JavaScript 对象的透明抽象层。代理可以定义包含捕获器的处理程序对象，而这些捕获器可以拦截绝大部分 JavaScript 的基本操作和方法。在这个捕获器处理程序中，可以修改任何基本操作的行为，当然前提是遵从捕获器不变式。</p>
<p>与代理如影随形的反射 API，则封装了一整套与捕获器拦截的操作相对应的方法。可以把反射 API 看作一套基本操作，这些操作是绝大部分 JavaScript 对象 API 的基础。</p>
<p>代理的应用场景是不可限量的。开发者使用它可以创建出各种编码模式，比如（但远远不限于）跟踪属性访问、隐藏属性、阻止修改或删除属性、函数参数验证、构造函数参数验证、数据绑定，以及可观察对象。</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>代理</tag>
        <tag>Proxy</tag>
        <tag>反射</tag>
        <tag>Reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript中的垃圾回收</title>
    <url>/2021/06/25/javascript/javascript%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<p>在浏览器的发展史上，用到过两种主要的标记策略：标记清理和引用计数。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<h2 id="标记清理"><a href="#标记清理" class="headerlink" title="标记清理"></a>标记清理</h2><p>JavaScript 最常用的垃圾回收策略是标记清理（mark-and-sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。</p>
<p>给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。<br>垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。</p>
<p>到了 2008 年，IE、Firefox、Opera、Chrome 和 Safari 都在自己的 JavaScript 实现中采用标记清理（或其变体），只是在运行垃圾回收的频率上有所差异。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>另一种没那么常用的垃圾回收策略是引用计数（reference counting）。其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。<br>如果同一个值又被赋给另一个变量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。<br>垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存。<br>引用计数最早由 Netscape Navigator 3.0 采用，但很快就遇到了严重的问题：循环引用。所谓循环引用，就是对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A。<br>为避免类似的循环引用问题，应该在确保不使用的情况下切断原生 JavaScript 对象与 DOM 元素之间的连接。</p>
<p>比如，通过以下代码可以清除前面的例子中建立的循环引用：</p>
<pre><code>myObject.element = null;￼
element.someObject = null;
</code></pre>
<p>把变量设置为 null 实际上会切断变量与其之前引用值之间的关系。当下次垃圾回收程序运行时，这些值就会被删除，内存也会被回收。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>写得不好的 JavaScript 可能出现难以察觉且有害的内存泄漏问题。在内存有限的设备上，或者在函数会被调用很多次的情况下，内存泄漏可能是个大问题。JavaScript 中的内存泄漏大部分是由不合理的引用导致的。</p>
<ol>
<li>意外声明全局变量是最常见但也最容易修复的内存泄漏问题。</li>
<li>定时器也可能会悄悄地导致内存泄漏。下面的代码中，定时器的回调通过闭包引用了外部变量：</li>
</ol>
<pre><code>let name = &#39;Jake&#39;;￼
setInterval(() =&gt; &#123;￼ console.log(name);￼ &#125;, 100);
</code></pre>
<p>只要定时器一直运行，回调函数中引用的 name 就会一直占用内存。</p>
<ol start="3">
<li>使用 JavaScript 闭包很容易在不知不觉间造成内存泄漏。请看下面的例子：</li>
</ol>
<pre><code>let outer = function() &#123;￼
    let name = &#39;Jake&#39;;￼
    return function() &#123;￼
        return name;
￼ &#125;;￼
&#125;;
</code></pre>
<p>调用 outer()会导致分配给 name 的内存被泄漏。以上代码执行后创建了一个内部闭包，只要返回的函数存在就不能清理 name，因为闭包一直在引用着它。假如 name 的内容很大（不止是一个小字符串），那可能就是个大问题了。</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript面向对象</title>
    <url>/2021/06/27/javascript/javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>本文介绍了 javascript 中创建对象的方法以及实现继承的方法。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<h1 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h1><p>在 ES6 中类的概念出现之前，主要有以下创建对象的方法。注，ES6 的类都仅仅是封装了 ES5.1 构造函数加原型继承的语法糖而已。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是一种众所周知的设计模式，广泛应用于软件工程领域，用于抽象创建特定对象的过程。</p>
<pre><code>function createPerson(name, age, job) &#123;
  let o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function () &#123;
    console.log(this.name);
  &#125;;
  return o;
&#125;
let person1 = createPerson(&#39;Nicholas&#39;, 29, &#39;Software Engineer&#39;);
let person2 = createPerson(&#39;Greg&#39;, 27, &#39;Doctor&#39;);
</code></pre>
<h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><pre><code>function Person(name, age, job) &#123;
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function () &#123;
    console.log(this.name);
  &#125;;
&#125;
let person1 = new Person(&#39;Nicholas&#39;, 29, &#39;Software Engineer&#39;);
let person2 = new Person(&#39;Greg&#39;, 27, &#39;Doctor&#39;);
person1.sayName(); // Nicholas￼
person2.sayName(); // Greg
</code></pre>
<p>执行 new 操作符时，引擎内部会执行如下操作：</p>
<ul>
<li>在内存中创建一个新对象。</li>
<li>这个新对象内部的[[Prototype]]特性被赋值为构造函数的 prototype 属性。</li>
<li>构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。</li>
<li>执行构造函数内部的代码（给新对象添加属性）。</li>
<li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</li>
</ul>
<p>构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。因此对前面的例子而言，person1 和 person2 都有名为 sayName()的方法，但这两个方法不是同一个 Function 实例。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型。</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>ECMA-262 把原型链定义为 ECMAScript 的主要继承方式。其基本思想就是通过原型继承多个引用类型的属性和方法。</p>
<p>重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。</p>
<p>原型链虽然是实现继承的强大工具，但它也有问题。主要问题出现在原型中包含引用值的时候。前面在谈到原型的问题时也提到过，原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。</p>
<p>原型链的第二个问题是，子类型在实例化时不能给父类型的构造函数传参。事实上，我们无法在不影响所有对象实例的情况下把参数传进父类的构造函数。再加上之前提到的原型中包含引用值的问题，就导致原型链基本不会被单独使用。</p>
<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>为了解决原型包含引用值导致的继承问题，一种叫作“盗用构造函数”（constructor stealing）的技术在开发社区流行起来（这种技术有时也称作“对象伪装”或“经典继承”）。基本思路很简单：在子类构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用 apply()和 call()方法以新创建的对象为上下文执行构造函数。</p>
<ol>
<li>传递参数</li>
</ol>
<p>相比于使用原型链，盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参。</p>
<pre><code>function SuperType(name) &#123;
  this.name = name;
&#125;

function SubType() &#123;
  // 继承SuperType并传参￼
  SuperType.call(this, &#39;Nicholas&#39;);
  // 实例属性￼
  this.age = 29;
&#125;

let instance = new SubType();
console.log(instance.name); // &quot;Nicholas&quot;;
console.log(instance.age); // 29
</code></pre>
<ol start="2">
<li>盗用构造函数的问题</li>
</ol>
<p>盗用构造函数的主要缺点，也是使用构造函数模式自定义类型的问题：必须在构造函数中定义方法，因此函数不能重用。此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。由于存在这些问题，盗用构造函数基本上也不能单独使用。</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。</p>
<p>组合继承弥补了原型链和盗用构造函数的不足，是 JavaScript 中使用最多的继承模式。而且组合继承也保留了 instanceof 操作符和 isPrototypeOf()方法识别合成对象的能力。</p>
<pre><code>function SuperType(name) &#123;
  this.name = name;
  this.colors = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];
&#125;
SuperType.prototype.sayName = function () &#123;
  console.log(this.name);
&#125;;
function SubType(name, age) &#123;
  SuperType.call(this, name); //第二次调用SuperType()
  this.age = age;
&#125;
SubType.prototype = new SuperType(); //第一次调用SuperType()
SubType.prototype.constructor = SubType;
SubType.prototype.sayAge = function () &#123;
  console.log(this.age);
&#125;;
</code></pre>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>JavaScript 的继承主要通过原型链来实现。原型链涉及把构造函数的原型赋值为另一个类型的实例。这样一来，子类就可以访问父类的所有属性和方法，就像基于类的继承那样。原型链的问题是所有继承的属性和方法都会在对象实例间共享，无法做到实例私有。</p>
<p>盗用构造函数模式通过在子类构造函数中调用父类构造函数，可以避免这个问题。这样可以让每个实例继承的属性都是私有的，但要求类型只能通过构造函数模式来定义（因为子类不能访问父类原型上的方法）。</p>
<p>目前最流行的继承模式是组合继承，即通过原型链继承共享的属性和方法，通过盗用构造函数继承实例属性。</p>
<h2 id="其他继承方式"><a href="#其他继承方式" class="headerlink" title="其他继承方式"></a>其他继承方式</h2><p>除上述模式之外，还有以下几种继承模式。<br>❑ 原型式继承可以无须明确定义构造函数而实现继承，本质上是对给定对象执行浅复制。这种操作的结果之后还可以再进一步增强。<br>❑ 与原型式继承紧密相关的是寄生式继承，即先基于一个对象创建一个新对象，然后再增强这个新对象，最后返回新对象。这个模式也被用在组合继承中，用于避免重复调用父类构造函数导致的浪费。<br>❑ 寄生组合继承被认为是实现基于类型继承的最有效方式。</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>2006 年，Douglas Crockford 写了一篇文章：《JavaScript 中的原型式继承》（“Prototypal Inheritance in JavaScript”）。这篇文章介绍了一种不涉及严格意义上构造函数的继承方法。他的出发点是即使不自定义类型也可以通过原型实现对象之间的信息共享。文章最终给出了一个函数：</p>
<pre><code>function object(o) &#123;
  function F() &#123;&#125;
  F.prototype = o;
  return new F();
&#125;
</code></pre>
<p>Crockford 推荐的原型式继承适用于这种情况：你有一个对象，想在它的基础上再创建一个新对象。你需要把这个对象先传给 object()，然后再对返回的对象进行适当修改。</p>
<p>ECMAScript 5 通过增加 Object.create()方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>与原型式继承比较接近的一种继承方式是寄生式继承（parasitic inheritance），也是 Crockford 首倡的一种模式。寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。</p>
<pre><code>function createAnother(original) &#123;
  let clone = object(original); // 通过调用函数创建一个新对象
  clone.sayHi = function () &#123;
    // 以某种方式增强这个对象￼
    console.log(&#39;hi&#39;);
  &#125;;
  return clone; // 返回这个对象
&#125;
</code></pre>
<p>寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景。object()函数不是寄生式继承所必需的，任何返回新对象的函数都可以在这里使用。注意: 通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。</p>
<h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><p>组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在子类构造函数中调用。本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。</p>
<h1 id="ES6-Class"><a href="#ES6-Class" class="headerlink" title="ES6 Class"></a>ES6 Class</h1><p>抽象基类<br>有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。虽然 ECMAScript 没有专门支持这种类的语法，但通过 new.target 也很容易实现。</p>
<p>new.target 保存通过 new 关键字调用的类或函数。通过在实例化时检测 new.target 是不是抽象基类，可以阻止对抽象基类的实例化：</p>
<pre><code>// 使用 new.target 实现 ES6 抽象基类
class Vehicle &#123;
  constructor() &#123;
    console.log(new.target);
    if (new.target === Vehicle) &#123;
      throw new Error(&#39;Vehicle cannot be directly instantiated&#39;);
    &#125;
  &#125;
&#125;

new Vehicle(); // Error: Vehicle cannot be directly instantiated
</code></pre>
<p>另外，通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法。因为原型方法在调用类构造函数之前就已经存在了，所以可以通过 this 关键字来检查相应的方法：</p>
<pre><code>// 抽象基类
class Vehicle &#123;
  constructor() &#123;
    if (new.target === Vehicle) &#123;
      throw new Error(&#39;Vehicle cannot be directly instantiated&#39;);
    &#125;

    if (!this.foo) &#123;
      throw new Error(&#39;Inheriting class must define foo()&#39;);
    &#125;
    console.log(&#39;success! &#39;);
  &#125;
&#125;

// 派生类
class Bus extends Vehicle &#123;
  foo() &#123;&#125;
&#125;

// 派生类
class Van extends Vehicle &#123;&#125;

new Bus(); // success!
new Van(); // Error: Inheriting class must define foo()
</code></pre>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>面向对象</tag>
        <tag>原型继承</tag>
      </tags>
  </entry>
  <entry>
    <title>前端好文</title>
    <url>/2021/06/29/web%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%A5%BD%E6%96%87/</url>
    <content><![CDATA[<p>日常收集的关于前端开发的优秀文章，多读多消化。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API">web API 接口参考</a></p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events">web 事件参考</a></p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference">javascript 参考 MDN</a></p>
</li>
<li><p><a href="https://iwiki.woa.com/pages/viewpage.action?pageId=375828171">前端监控实现原理</a></p>
</li>
<li><p><a href="http://km.oa.com/group/sitepoint/articles/show/364557">前端监控实现思路</a></p>
</li>
<li><p><a href="http://km.oa.com/group/32560/articles/show/365524">emonitor 前端监控实现</a></p>
</li>
<li><p><a href="https://www.wxapp-union.com/article-6184-1.html">小程序监控</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6844903617292402702">小程序异常监控收集</a></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html">JavaScript Source Map 详解</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/1TQwNx0Q69qEBcoXwJ-Vpg">来看看字节是如何做前端异常监控的，source 简介</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/rJ0yMBcDvm9KD0OF2gLfAA">从微服务到微前端：浅谈微前端的设计思想</a></p>
</li>
<li><p><a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/">useEffect 完整指南</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/JURLrg4VCBDCN3vttV4ahQ">react hooks 原理</a></p>
</li>
<li><p>精读《React Hooks》</p>
</li>
<li><p>精读《怎么用 React Hooks 造轮子》</p>
</li>
<li><p>精读《useEffect 完全指南》</p>
</li>
<li><p>精读《Function VS Class 组件》</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/-dVGGoVA8kpv9PaSNMoMSg">React 性能优化完全指南</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/UPy5Qwesz8ia3XpjrUJ4oQ">深入理解 React Router：Context、Hooks、Refs、Memo 特性讲解</a></p>
</li>
<li><p><a href="https://github.com/linqinghao/blog/issues/18">Typescript 中的装饰器与元数据反射</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/PFgc8xD7gT40-9qXNTpk7A">Typescript 装饰器详解</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000021508564">使用 typescript 装饰器构建 nodejs 路由</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/215385588">使用 typescript 装饰器构建 nodejs 路由</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/QcVA6yEw3NvDV1ZLtoMcug">手写一个脚手架</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000020335010?utm_source=sf-similar-article">手把手教你搭建脚手架工具</a></p>
</li>
<li><p><a href="http://www.semlinker.com/categories/node-js/">深入学习 nodejs 系列</a></p>
</li>
<li><p><a href="https://yjhjstz.gitbooks.io/deep-into-node/content/">deep-into-node</a></p>
</li>
<li><p><a href="https://jishuin.proginn.com/p/763bfbd57afc">虚拟列表实现原理</a></p>
</li>
<li><p><a href="https://jishuin.proginn.com/u/548404">这个用户下有些文章质量挺高</a></p>
</li>
<li><p><a href="https://jishuin.proginn.com/p/763bfbd4cedb">学会 Proxy 真的可以为所欲为</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/Etied9JkAB2jZUMvD4LWIA">腾讯课堂小程序性能极致优化</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端好文</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>优秀文章</tag>
      </tags>
  </entry>
  <entry>
    <title>前端监控思路和实现</title>
    <url>/2021/07/05/web%E5%89%8D%E7%AB%AF/%E7%AB%AF%E7%9B%91%E6%8E%A7%E6%80%9D%E8%B7%AF%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>前端监控主要包括信息的采集、上报和告警。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<h2 id="前端需要监控什么内容"><a href="#前端需要监控什么内容" class="headerlink" title="前端需要监控什么内容"></a>前端需要监控什么内容</h2><ol>
<li>错误监控<ul>
<li>1.1 js 执行错误</li>
<li>1.2 ajax 错误</li>
<li>1.3 promise 错误</li>
<li>1.4 静态资源加载错误</li>
<li>1.5 本地输入的 console 日志</li>
</ul>
</li>
<li>CGI 测速（响应码、响应耗时）</li>
<li>静态资源质量（耗时）</li>
<li>页面质量（首屏耗时）</li>
<li>平台或网络信息</li>
</ol>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="错误监控"><a href="#错误监控" class="headerlink" title="错误监控"></a>错误监控</h3><ol>
<li>js 脚本执行错误时会触发页面的 onerror 事件，通过该事件可以捕获到脚本执行错误。</li>
</ol>
<pre><code>window.onerror = function(message, source, lineno, colno, error) &#123;
    // message: 错误信息
    // source: 发生错误的脚本URL
    // lineno: 发生错误的行号
    // colno: 发生错误的列号
    // error： 错误对象
&#125;
</code></pre>
<ol start="2">
<li>静态资源加载错误时，会被 <code>window.addEventListener(&#39;error&#39;, func, true)</code>(注意第三个参数) 捕获。</li>
</ol>
<pre><code>// 捕获静态资源加载错误
// 注意第三个参数为true，表示要在事件捕获阶段处理
window.addEventListener(&#39;error&#39;, function(e)&#123;
    // 上报错误
&#125;, true);
</code></pre>
<ol start="3">
<li>promise 异常会触发页面的 unhandledrejection 事件，可以通过该事件捕获异常。</li>
</ol>
<pre><code>window.addEventListener(&#39;unhandledrejection&#39;, function(err) &#123;
    // 上报错误
&#125;, true);
</code></pre>
<ol start="4">
<li>CGI 监控</li>
</ol>
<p>CGI 监控的方式有两种，一种是业务方接口调用失败时，主动上报；另一种是改写 ajax 和 fetch 方法来实现上报。第二种方法对业务无侵入，比较灵活，但是上报信息可能不如第一种详细。</p>
<pre><code>//改写 fetch
function overrideFetch() &#123;
  ...
  const originFetch = window.fetch;
  window.fetch = (url, option) =&gt; &#123;
    return originFetch(url, option)
    .then(res =&gt; &#123;
      // 在这里拦截到接口请求情况进行上报处理
      ...
    &#125;)
  &#125;
&#125;

// 改写XHR
const xhrProto = window.XMLHttpRequest.prototype,
    originSend = xhrProto.send;
    xhrProto.send = function aegisFakeXhrSend() &#123;
    // 在这里获取请求情况进行上报处理
    ...
    return originSend.apply(this, arguments)
&#125;
</code></pre>
<ol start="5">
<li>console 日志监控</li>
</ol>
<p>前端代码中经常会使用 console 来打印日志，其中 console.error 中抛出的信息可能对我们有用。可以通过改写底层的 console.error 方法来上报数据。</p>
<pre><code>if (typeof console !== &#39;undefined&#39; &amp;&amp; typeof console.error === &#39;function&#39;) &#123;
    const nativeConsoleError = console.error;
    console.error = (...rest) =&gt; &#123;
    nativeConsoleError.apply(window.console, rest);
    // 发送错误信息到服务器
    &#125;;
&#125;
</code></pre>
<h3 id="静态资源质量"><a href="#静态资源质量" class="headerlink" title="静态资源质量"></a>静态资源质量</h3><p>前端静态资源主要包括 img、css、script、link、audio、video 这几大块内容。可以通过 performance API 来收集所有静态资源的请求情况，然后利用 performance.timing 获取每个时间节点来计算静态资源的加载情况。</p>
<pre><code>function collect() &#123;
    const entries = performance.getEntriesByType(&#39;resource&#39;);

    for (let i = 0, l = entries.length; i &lt; l; i++) &#123;
        const entry = entries[i] as StaticPerformanceResourceTiming;
        if ([&#39;link&#39;, &#39;img&#39;, &#39;script&#39;].includes(entry.initiatorType)) &#123;
            // dns解析时间
            const DNSResolveTime = entry.domainLookupEnd - entry.domainLookupStart;
            // 响应总时间
            const respTime = entry.responseEnd - entry.startTime;
            // 其他时间，参考 performance API

            const resourceName = entry.name;
            // 上报
            report(&#123; event: &#39;static-resource&#39;, name: resourceName, data: &#123; DNSResolveTime, respTime&#125; &#125;);
        &#125;
    &#125;
&#125;

// 可以开启定时器，定时收集上报
setInterval(collect, this.config.collectInterval);
</code></pre>
<h3 id="CGI-测速"><a href="#CGI-测速" class="headerlink" title="CGI 测速"></a>CGI 测速</h3><p>同样的，通过改写 ajax 和 fetch，可以获取请求和响应的时间点，从而计算得出 CGI 的请求耗时。</p>
<h3 id="页面质量"><a href="#页面质量" class="headerlink" title="页面质量"></a>页面质量</h3><p>在页面性能中，最重要的是计算<code>首屏渲染时间</code>。</p>
<p>由于 React 、Vue 等框架的出现，DOMContentLoaded 事件已经失去了原本的作用，现在 “首屏渲染时间” 的计算大多数时候是依靠人工打点，这样会侵入业务，使用不便。下面介绍一套新的算法，尽可能准确的对 “首屏渲染时间” 进行估算，主要运用到了 MutationObserver、performance。</p>
<p>MutationObserver 提供了监听页面 DOM 树变化的能力：</p>
<pre><code>// 注册监听函数
const observer = new MutationObserver((mutations) =&gt; &#123;
    // 获取增加的节点
    for(let i = 0; i &lt; mutations.length; i++) &#123;
        console.log(mutations[0].addedNodes);
    &#125;
&#125;);

// 监听 document 的节点变化
observer.observe(document, &#123;
    childList: true,
    subtree: true
&#125;);
</code></pre>
<p><code>performance</code> API 能计算资源加载的时间（详见上文静态资源收集）</p>
<p>通过 MutationObserver 观察页面 dom 树的变化，只关心 nodeType === 1 的元素，且剔除 script、style 等不会在页面中展示出来的元素节点，最后比较找出<code>首屏节点完成耗时最大的一个</code>作为 firstScreenTiming 首屏渲染时间。</p>
<p>但这个 firstScreenTiming 首屏渲染时间还不是最终确认得到的最大渲染时间，我们都知道页面的“加载完整”除了节点元素加载完毕外，首屏中的图片加载完成也是一个判断标准。得益于浏览器提供的 performance API ，这个计算过程非常简单高效。</p>
<pre><code>window.performance.getEntriesByType(&#39;resource&#39;).forEach((resource: any) =&gt; &#123;
    if (
        resource.initiatorType === &#39;img&#39; &amp;&amp;
        resource.responseEnd &gt; maxTime
    )&#123;
        //遍历找出图片资源加载中耗时最大的一个
        //并与 DOM 节点加载得到的‘首屏渲染时间’比较，取最大的值作为真正的 firstScreenTiming
    &#125;
&#125;);
</code></pre>
<h3 id="平台或网络信息"><a href="#平台或网络信息" class="headerlink" title="平台或网络信息"></a>平台或网络信息</h3><p>平台设备信息可以通过 UserAgent 解析而来。</p>
<p>网络信息可以通过 navigator.connection API 获取到。</p>
<pre><code>const result = navigator.connection;
result.effectiveType; // 2g, 3g, 4g, 5g, wifi ... 注意，该结果是浏览器根据当前网速的测算值，不一定准确
result.downlink;      // 网络下行速度，单位为 Mbits/s
result.rtt;           // 估算的往返时间
result.obChange = function()&#123;&#125;;  // 网络变更时触发
</code></pre>
<h2 id="离线日志"><a href="#离线日志" class="headerlink" title="离线日志"></a>离线日志</h2><p>可以考虑使用 IndexedDB 在用户本地存储离线日志，这样就算因为用户网络不佳，无法进行通信，日志也会被记录下来，在后续合适的时机进行上报。</p>
<h2 id="数据上报和告警"><a href="#数据上报和告警" class="headerlink" title="数据上报和告警"></a>数据上报和告警</h2><p>可以使用 ElasticSearch 来存储日志，配合 Kibana 查询展示。</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>前端监控</tag>
      </tags>
  </entry>
  <entry>
    <title>江雪</title>
    <url>/2021/06/28/%E8%AF%97%E8%AF%8D/%E6%B1%9F%E9%9B%AA/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>诗词</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>柳宗元</tag>
      </tags>
  </entry>
  <entry>
    <title>遇见春天遇见你</title>
    <url>/2021/06/22/%E8%AF%97%E8%AF%8D/%E9%81%87%E8%A7%81%E6%98%A5%E5%A4%A9%E9%81%87%E8%A7%81%E4%BD%A0/</url>
    <content><![CDATA[<p>沾衣欲湿杏花雨，春风十里不如你。</p>
<p>东晋永和年间，一个叫祝英台的姑娘，女扮男装，在一个明媚的春天，走出家门，去杭城求学，在春天的路上，他碰到了一个叫梁山伯的小伙子，他们草桥结拜，开始了一段化蝶的传说。一千多年来，你依旧可以在花海树影中，看到他们双宿双飞，为爱徘徊。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<p>东晋咸安年间，正当壮年的王献之走出家门，在桃花汛到来的时节，来到金陵的河边，在一个渡口，碰到一个叫桃叶的姑娘，从此金风玉露一相逢，便胜却人间无数。后来这个渡口也因为他们的相遇，从此被叫做桃叶渡。</p>
<p>大唐贞元十一年，落榜的考生崔护，在百无聊赖中去郊外春游，只是因为口渴讨水，便遇到一个叫绛娘的姑娘。第二年，他念念不忘，又有回想，又在春天重游故地，在绛娘家的门上，留下一首绝句。去年今日此门中，人面桃花相映红，人面不知何处去，桃花依旧笑春风。绛娘因此死，绛娘因此生，崔护也因此名传千古。</p>
<p>大唐元和四年，三十岁的袁震任监察御史，出使西蜀，当时正值春天，意气风发的袁震来到西川，和才女薛涛在那个山花烂漫的春天里，开始了一段惊天动地的姐弟恋。</p>
<p>事实上，春天的故事远不止这些。</p>
<p>墙头马上里的李千金，只因为是春天，忍不住站在墙边的软梯上，探头向外一望，就望见了那个比裴勇俊还要帅上几分的裴少俊。据说，唐伯虎也是在春游灵隐寺的时候，初见秋香，惊为天人。浮生六记里的沈复和芸娘，他们的春游更成为那个时代的经典。至于白娘子之遇许仙，完全是因为一千七百年前的一个小牧童，在春天放牧的时候，救了一小白蛇，然后才有了一千七百年后的西湖边的春天，他们断桥的遇见。</p>
<p>所以美丽的春天，不适合做宅女，不适合做宅男。</p>
<p>春天万物生发，生机盎然，适合走出门去，在生命最好的时候，让上苍恩赐一场遇见。</p>
<p>春风十里不如你啊，从一个日子走向另外一个日子，从一个春天走向另外一个春天，从一个自己走向另外一个自己。</p>
<p>跋涉的时候，遇见风，遇见雨，遇见他们，遇见星辰。</p>
<p>驻足的时候，遇见来，遇见去，遇见欢喜。</p>
<p>人生就是在路上，路上最大的幸福，就是遇见春天，遇见你。</p>
]]></content>
      <categories>
        <category>诗词</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>春天</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序优化</title>
    <url>/2021/07/21/web%E5%89%8D%E7%AB%AF/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>导语 | 如果你的小程序也遇到了性能问题，我们的实践经验也许可以给到你启发，我们从小程序的启动、加载到交互都进行了探索。顺便说一句，这篇文章在腾讯内部曾被小程序技术总监打赏。</p>
<ol>
<li>缘起<br>事情，要从一个周末惬意的下午开始说起……</li>
</ol>
<p>那天，手机突然被唤醒，弹出多条微信消息。原来是这周末正在校园推广的活动群发来的，想起之前大家有条不紊的开发进度，和产品沟通的友好过程，应该是活动反响不错。</p>
<p>现实是残酷的：</p>
<p>“我们的小程序打开慢成狗！”</p>
<p>“这个 loading 加载的过程也太久了！”</p>
<p>“滚动加载有点卡，而且很容易报错……”</p>
<p>看到的是最直接的控诉。</p>
<p>看到用户的录屏，这几个问题确实是有出现，所以我们还是需要对小程序进行一次主流程的性能优化，三句控诉可以总结为 3 个点：</p>
<p>小程序启动慢</p>
<p>小程序请求慢</p>
<p>小程序交互慢</p>
<p>2.定位<br>2.1. 启动慢<br>收到反馈后第一反应是，用户是不是网速太慢了，自己跑一遍，发现自己的手机跑起来都是没问题的，灰常流畅，下意识的可能想录个屏回复过去。</p>
<p>图片</p>
<p>不过有用户录屏在那，当然不能这么草率，所以我们查了下管理后台小程序在不同网络下的大盘数据：</p>
<p>网络 启动耗时<br>总体 3.6s<br>WIFI 3.5s<br>4G 3.9s<br>2G/3G 4.1s</p>
<p>从统计看，总体 3.7s 的启动耗时，网络对于启动耗时是会有影响的，但影响没有很大，就算是 2G-3G 下跟大盘的数据对比也没有慢很多，可见事情并不简单。</p>
<p>于是我们从另外一个维度来看一下大盘数据：</p>
<p>机型 启动耗时 JS 注入 初次渲染<br>总体 3.6s 0.29s 0.16s<br>高端机 2.9s 0.19s 0.06s<br>中端机 4.8s 0.42s 0.19s<br>低端机 7.9s 0.72s 0.43s<br>从这里就可以看出问题来了，手机的性能对于小程序的启动速度影响非常大，低端机相对高端机有 2-3 倍的差距，特别是渲染层甚至有 5-6 倍的差距，而且问题反馈的用户所使用的手机也确实是中低端机，但用户使用什么手机我们也没法控制，那这里有办法去优化吗？</p>
<p>针对这个问题，我们需要了解一下小程序的启动过程，根据官方文档的介绍，小程序的启动可以分为下面几个步骤：</p>
<p>图片</p>
<p>上图描述了用户点击小程序开始到页面开始请求数据的一个完整的冷启动过程，而小程序初始化的过程（信息准备、环境准备）占用了比较长的时间，但这部分的工作是由微信客户端来完成，开发者无法干预，所以我们只能聚焦于后续的步骤（下载代码包、注入代码包、初次渲染）。</p>
<p>根据官方文档的介绍，这一部分的可优化手段有：</p>
<p>减小代码包体积</p>
<p>降低代码复杂度</p>
<p>减少同步代码接口调用</p>
<p>降低页面结构复杂度</p>
<p>减少自定义组件数量</p>
<p>后面 4 条在技术上没有特别好的限制手段，需要我们在 Code Review 的时候对复杂度和开销大的接口调用进行把关，复杂度这里还可以借助如 CodeCC（腾讯内部代码检查工具） 这类工具去进行分析，减少自定义组件数量，这个是比较难以抉择的，需要在代码可读性、可复用性之间做个取舍，不是本次优化的重点。</p>
<p>所以我们就重点关注的代码包体积问题，通过我们的 CI 记录可以收集到我们的总包大小：</p>
<p>图片</p>
<p>可以看到主包体积达到 1949.71KB，接近了 2M 的极限了，在通过依赖分析后，发现除了一些是未使用到的模块和组件外，很大一部分内容是静态资源，同时我们也在官方文档中看到这样一句话：</p>
<p>小程序代码包在下载时会使用 ZSTD 算法进行压缩，这些资源文件会占用大量代码包体积，并且通常难以进一步被压缩，对于下载耗时的影响比代码文件大得多。</p>
<p>所以我们要减小代码包的体积，最直接的方法就是将非必要的资源去除掉：</p>
<p>对静态资源进行优化，将非必要的静态资源文件上传到 CDN</p>
<p>对小程序的组件进行依赖分析，过滤掉未使用的组件</p>
<p>同时我们还关注到，有一些分包特别小，但是由于是普通分包，在打开这些页面的时候还需要先下载主包，这里在包下载耗时上其实是有一些浪费的，比较典型的就是 WebView 页面，他们往往只需要对参数进行处理，对于主包的依赖不是很强，所以这里还有一个可以优化的点：</p>
<p>对独立性比较强的页面进行独立分包，尽可能的减少包下载耗时</p>
<p>2.2. 请求慢<br>我们通过日志查到这个用户的首页数据请求返回会到 3-4s，请求慢在正常情况下会有这么两种情况：</p>
<p>并发量突增导致服务器响应慢</p>
<p>用户网速较慢导致发送请求和接收请求变慢</p>
<p>我们通过日志统计发现用户的访问时间端，请求量跟平时保持一致，看大盘请求耗时的统计，也没有产生大的波动：</p>
<p>图片</p>
<p>所以基本可以排除是后台的问题，虽然大盘的数据在 500ms 左右，但是当用户网络不好的情况下，这一块要怎么保证呢？</p>
<p>答案当然是做提前拉取，当用户冷启动的时候，我们可以使用小程序官方提供的数据预拉取能力提前拉取，从小程序的启动耗时看，完全可以 cover 掉我们的接口请求耗时，可以让小程序启动成功后就直接渲染页面。</p>
<p>在热启动的情况下，请求慢主要体现在用户交互时发生的请求和页面切换时发生的请求，交互的情况我们下一节在分析，这里主要看页面切换，从我们的统计数据来看，页面切换的耗时大概在 400ms 左右，而其中能够利用的时间大概是 50ms-100ms：</p>
<p>图片<br>route 时间</p>
<p>利用页面切换的这个时间提前对页面的数据进行加载，可以减少用户感观上的数据请求时间，同时在第一次请求之后可以根据一定的策略对页面的数据进行缓存，从而可以达到二次进入页面秒开的效果。</p>
<p>总结来看，请求慢的优化手段有下面几个，而且理论上效果都会很显著：</p>
<p>冷启动开启数据预拉取</p>
<p>页面路由切换时提前拉取数据</p>
<p>对数据进行缓存</p>
<p>2.3. 交互慢<br>先说一下这里的交互慢具体指什么，我们收到用户反馈的现象是：用户首屏顺利加载出来之后，后续滚动加载和一些按钮点击的响应非常慢并且很容易报错。收到这个反馈后定位了很久，讲道理如果是因为用户网络问题导致的请求很慢，应该所有的请求都会很慢，但是用户表现出来的现象是后续的加载以及交互很慢，反而首屏还算正常。</p>
<p>通过日志查询，我们发现这个用户的请求报错都是请求超时，为什么超时会集中在交互加载这里呢？定位了一段时间后我们发现一个用户的报错都集中在首屏加载之后就立马下滑或者点击，如果过了一段时间再点击又不会报错。</p>
<p>发现这个现象后，我们想到了官方文档关于网络使用说明的一个限制：</p>
<p>wx.request、wx.uploadFile、wx.downloadFile 的最大并发限制是 10 个</p>
<p>再结合我们对于 wx.request 的封装，请求超时的计时器是从调用 wx.request 的时候就开始了，如果请求并发超过了限制，那么就很容易出现请求超时，而当我们从第一个业务接口请求到数据后就会进行一系列的数据上报，包括 pv、组件曝光、关键链路打点等等，所以我们利用 Whistle 的 resDelay 方法，将我们的上报请求都延迟 5000ms 返回，果然就复现了用户反馈的那种情况。</p>
<p>图片</p>
<p>找到问题之后也就明确了需要优化的方向：</p>
<p>保障与用户体验相关的业务请求正常发送</p>
<p>交互慢还有别的原因吗？在继续挖掘性能瓶颈的过程中，发现腾讯课堂小程序的课程详情页内容非常多，有 5-6 屏的高度，而用户只会关心首屏是不是更快的呈现出来，但是我们原本的处理方式是比较粗暴的，拿到详情页的数据之后对数据进行处理，格式化成整个页面所需要的数据之后一次性调用 this.setData 来更新页面，所以如果要提升首屏速度，这里需要做的就是：</p>
<p>页面分步渲染</p>
<p>2.4. 优化点归总<br>再归总一下需要优化的点和方向：</p>
<p>启动慢主要从优化代码包上下手：</p>
<p>对静态资源进行优化，将非必要的静态资源文件上传到 CDN</p>
<p>对小程序的组件进行依赖分析，过滤掉未使用的组件</p>
<p>对独立性比较强的页面进行独立分包，减少主包下载耗时</p>
<p>请求慢主要从预加载和缓存下手：</p>
<p>冷启动开启数据预拉取</p>
<p>页面路由切换时提前拉取数据</p>
<p>对数据进行缓存</p>
<p>交互慢需要从发起请求和页面渲染下手：</p>
<p>保障与用户体验相关的业务请求正常发送</p>
<p>页面分步渲染</p>
<ol start="3">
<li>优化<br>3.1. 启动优化<br>3.1.1. 独立分包<br>由于用户反馈主要是因为校园推广活动来的，而活动页面我们是通过 WebView 内嵌 H5 来承载的，而 WebView 页面的启动过程和小程序原生页面还不太一样：</li>
</ol>
<p>图片</p>
<p>实际上 WebView 页面只需要完善登录态传递的功能，对于主包的依赖不是很大，而且这部分页面更大的性能问题需要在 h5 那边来优化，所以我们第一时间对其进行了独立分包处理。</p>
<p>最终的优化效果还不错，因为启动过程中不需要下载主包，启动性能提升了 30%。</p>
<p>3.1.2. 静态资源上 CDN<br>我们小程序构成主要是由原生页面 + kbone 页面组成的，kbone 是采用的官方的方案，通过 webpack 构建，有很多单独打包静态资源的方案。而我们的原生页面是使用 gulp 进行构建的，原来主要的功能是将源码中的 ts 转成 js，同时对 css 文件通过 postcss 转成 wxss，由于 wxss 不支持引用相对路径，所以在 wxss 中引用的图片和字体都是转成 base64 的，然后对其余的文件如 json、wxml 文件则直接复制到产物中去。</p>
<p>这样的处理方式比较粗暴，通过 postcss 将 background-image 所引用的本地图片都转成 base64，还会导致很多图片在项目中占用了 2 倍的体积。</p>
<p>图片<br>CI 流程-优化前</p>
<p>所以我们首先需要将源码下的静态资源匹配到并单独构建出来，并且为了规避同名文件的问题，需要对资源打个 hashtag，我们这里需要用到一个 gulp 插件 gulp-rev，这个插件可以对基于资源的内容进行 hash。</p>
<p>图片<br>CI 流程-优化后</p>
<p>将图片上到 CDN 后，把 css、js、json、wxml 中的引用路径替换成 CDN 地址，具体的替换逻辑如下。</p>
<p>图片<br>CDN 流程</p>
<p>3.1.3. 过滤未使用组件<br>随着业务的迭代，不可避免的会有一些组件被废弃了但是难以察觉，通过我们团队开发的小程序脚手架 imweb-miniprogram-cli 对页面所使用到的组件进行分析，可以把项目中未使用到的组件给过滤出来，不会打包到最终的产物中，大致的思路如下：</p>
<p>图片<br>组件依赖</p>
<p>从 app.json 开始，拿到小程序所配置的所有页面和分包，通过检查 App、页面、分包中所使用的自定义组件来进行收集，并且递归检查自定义组件所使用的组件，如果检测到有未使用的组件，也会给到提示，非常友好：</p>
<p>图片<br>组件过滤</p>
<p>可以看到在我们的项目中就发现了好几个未使用到的组件。</p>
<p>3.2. 请求优化<br>3.2.1. 数据预拉取<br>数据预拉取需要在小程序的管理后台开启，数据来源可以选择开发者服务器或者云开发，选择开发者服务器的话会有一些限制，如果是直接填写 CGI 地址，就只能拉取一种数据，不够灵活，而如果再搭建一个服务去做预拉取涉及到的工作量又会很大，所以我们选择的是云开发的方式，大致流程如下图:</p>
<p>图片<br>数据预拉取-大概</p>
<p>当小程序启动的时候，微信客户端会根据配置去拉取指定的云函数，在云函数中通过 cl5 调用业务后台的服务拉取到需要的数据，拉取到后客户端会将数据缓存在本地，当小程序启动成功后，在业务代码中调用 wx.getBackgroundFetchData 就可以拿到预拉取的数据，如果缓存数据拉到的是所需要的数据则可以直接渲染，如果不是则降级到业务中再拉一次接口。</p>
<p>在云函数中可以拿到本次小程序启动的 path 和 query 参数，所以我们可以根据这两个参数来判断本次预拉取需要调用业务后台的哪个服务，从而达到从不同的页面启动小程序都可以通过一个云函数预拉取到所需要的数据。</p>
<p>const preFetchMap = {<br>‘pages/index/index’: fetchIndex,<br>‘pages/course/course’: fetchCourse,<br>}</p>
<p>// 云函数入口函数<br>exports.main = async (event) =&gt; {<br>const { path, query = ‘’ } = event;<br>const fetchFn = preFetchMap[path];</p>
<p>if (fetchFn) {<br>const res = await fetchFn(query);<br>return res;<br>}</p>
<p>return {<br>error: {<br>event,<br>retcode: -1002,<br>msg: <code>$&#123;path&#125;页面未设置预拉取逻辑</code><br>}<br>};<br>};</p>
<p>不过要注意的是，因为小程序自身做了很多初始化的优化，有可能在小程序启动后，预拉取的数据还没有返回，所以我们做了进一步的优化，在业务拉取的过程中通过 wx.onBackgroundFetchData 监听预拉取的返回，收到返回就直接渲染 ，尽可能的使用预拉取的数据来渲染首屏。</p>
<p>图片<br>数据预拉取</p>
<p>3.2.2. 提前拉取 &amp; 数据缓存<br>前面已经提到过，提前拉取就是要利用小程序切换页面的空隙开始拉取数据，从而在感官上较少数据请求的时间，整体的逻辑是通过封装的跳转逻辑，对应的页面添加不同的数据拉取逻辑，并将拉取的 promise 挂载在 App 上，当页面切换完成后优先使用 App 上的 promise 来获取数据。</p>
<p>数据缓存则是在数据拉取成功后，将比较固定的数据通过 wx.setStorage 缓存在本地，当第二次切换到这个页面时，先使用本地缓存的数据进行渲染，后面再通过拉取的数据来进行更新。</p>
<p>图片<br>提前拉取</p>
<p>3.3. 交互优化<br>3.3.1. 业务请求保障<br>保障业务请求的核心思路是让业务请求优先，我们封装了一个 排队请求模块 ，通过对 wx.request API 的拦截，将请求根据配置有个优先级排序，低优先级的会在请求并发数达到一定的阈值之后被推到等待队列 WaitingQueue 中，留出足够的通道给到高优先级的业务请求。</p>
<p>图片<br>请求排队</p>
<p>3.3.2. 分步渲染<br>这里的方案相信大家也能很好理解，主要是优先处理首屏需要的数据并通过 setData 更新视图，然后在处理其余的数据。但根据官方文档的说明：</p>
<p>setData 函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data 的值（同步）。</p>
<p>而小程序代码执行顺序也遵循 JS 的事件循环机制，仅仅是在处理后的数据调用 setData ，然后继续或者通过 Promise 处理下一步的话，并不能达到分步渲染的目的，而直接通过回调的方式在 setTimeout 中使用嵌套渲染，代码的可读性会变差，同时也不是很优雅。我们的解决方式是利用 setTimeout 封装了一个符合 Promise 标准的方法，从而可以像使用 Promise 那样继续分步渲染：</p>
<p>图片</p>
<ol start="4">
<li>成果<br>经过这一系列的优化，效果还是比较明显的：</li>
</ol>
<p>4.1. 包大小<br>在包大小方面：</p>
<p>总包从 9132.94KB 减小到 6736.42KB，减少了 27%；</p>
<p>主包从 1949.71KB 减小到 985.96KB，减少了 49.5%；</p>
<p>从启动耗时的数据看，下载耗时和 JS 注入耗时都有明显的下降：</p>
<p>图片<br>启动耗时</p>
<p>再看打开耗时分布，可以看到 3s 内打开的用户比例有明显增加，从 56.26%增加到 64.25%;</p>
<p>图片<br>打开分布</p>
<p>4.2. 请求耗时<br>数据预拉取，提前拉取，数据缓存在冷启动和页面切换时都起到了很不错的效果：</p>
<p>首页请求速度从平均 400ms 下降到 50ms，优化了 87.5%；</p>
<p>课详页的请求速度从平均 800ms 下降到 90ms，优化了 88.75%；</p>
<p>而数据缓存让二次访问时页面可以秒开：</p>
<p>图片<br>二次加载</p>
<p>使用排队请求之后，对网络请求顺序的干预效果还比较明显，灰度用户业务请求耗时平均有 50-100ms，约 15%的优化；</p>
<p>同时我们通过分析耗时分别在 80 分位、50 分位、20 分位的效果发现，请求耗时越长，优化效果越明显，也就是说在弱网情况下能够更好的发挥作用。</p>
<p>图片<br>请求排队结果</p>
<p>4.3. 渲染<br>使用分步渲染后，我们的页面可以在处理完首屏的基础数据之后就立即开始渲染了，由于我们的目录结构比较复杂，处理起来耗时比较长，所以第二部才处理目录，实际的渲染效果如下图:</p>
<p>图片<br>分步渲染</p>
<p>首屏可以比原来提前 100ms-150ms 渲染出来。</p>
<ol start="5">
<li>总结<br>我们本次的性能优化对小程序启动、请求、交互、渲染多个方面都进行了性能的挖掘，是在对基础库版本要求不高的情况下能做到的极致了。</li>
</ol>
<p>以我们的核心页面首页和课程详情页来说：</p>
<p>首页冷启动耗时开发者可干预的部分优化大概是 1300 下载 + 300 注入 + 170 首渲 + 430 请求 = 2200ms -&gt; 750 + 245 + 170 + 50 = 1215ms，优化了 45%</p>
<p>课详页冷启动耗时开发者可干预的部分优化大概是 1300 下载 + 300 注入 + 170 首渲 + 790 请求 = 2560ms -&gt; 750 + 245 + 170 + 100 = 1265ms，优化了 50.5%</p>
<p>页面切换首次进入详情页耗时从 400 路由 + 800 请求 + 450 处理 = 1650ms -&gt; 400 + 720 + 300 = 1420ms，优化了 14%</p>
<p>二次进入详情页面几乎看不到加载和渲染过程</p>
<p>还有更多的优化手段吗？官方还提供了一些比较高级的功能，对基础库版本要求比较高的，例如：</p>
<p>组件的按需注入和用时注入可以进一步减小代码包下载耗时，但是在我们发布时这个功能还有点问题，会导致首页的自定义组件加载不出来，所以暂时没有使用到。</p>
<p>还可以使用 2.11.1 开始支持的初始渲染缓存，不必等到逻辑层初始化完毕，可以更早的开始渲染视图。</p>
<p>尚在试验阶段的分包异步化，利用异步加载模块的方式也可以减少代码包的下载耗时和 JS 的注入耗时。</p>
<p>利用这些能力可以在更多细节上进行优化，我们也将进一步探索和跟进，如果你有更好的方案欢迎讨论。</p>
]]></content>
  </entry>
  <entry>
    <title>从浏览器输入URL到显示页面发生了什么</title>
    <url>/2021/07/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>从浏览器输入网址到页面显示的全过程。</p>
<!-- 这是注释：下面的标签表示文章只显示之前的内容作为摘要 -->
<span id="more"></span>

<h2 id="流程概览"><a href="#流程概览" class="headerlink" title="流程概览"></a>流程概览</h2><ol>
<li>web 浏览器： 当我们输入网址时，浏览器就会按照一定的规则去分析这个网址的含义，然后根据其含义生成请求消息；接着浏览器会将请求消息发送给 Web 服务器。当然，浏览器并不会亲自负责数据的传送。传送消息是搬运数字信息的机制负责的工作，因此浏览器会委托它将数据发送出去。具体来说，就是委托操作系统中的网络控制软件将消息发送给服务器。</li>
<li>协议栈、网卡： 协议栈（网络控制软件叫作协议栈）这个软件会将从浏览器接收到的消息打包，然后加上目的地址等控制信息。如果拿邮局来比喻，就是把信装进信封，然后在信封上写上收信人的地址。这个软件还有其他一些功能，例如当发生通信错误时重新发送包，或者调节数据发送的速率等，或许我们可以把它当作一位帮我们寄信的小秘书。接下来，协议栈会将包交给网卡（负责以太网或无线网络通信的硬件）。然后，网卡会将包转换为电信号并通过网线发送出去。这样一来，包就进入到网络之中了。</li>
<li>集线器、交换机、路由器： 接下来出场的物品会根据接入互联网的形式不同而不同。客户端计算机可以通过家庭或公司的局域网接入互联网，也可以单独直接接入互联网。以现在最典型的场景为例，假设客户端计算机是连接到家庭或公司的局域网中，然后再通过 ADSL 和光纤到户（FTTH）等宽带线路接入互联网。在这样的场景中，网卡发送的包会经过交换机等设备，到达用来接入互联网的路由器。路由器的后面就是互联网，网络运营商会负责将包送到目的地，就好像我们把信投到邮筒中之后，邮递员会负责把信送给收件人一样。</li>
<li>接入网、网络运营商： 接下来，数据从用来接入互联网的路由器出发，进入了互联网的内部。互联网的入口线路称为接入网。一般来说，我们可以用电话线、ISDN、ADSL、有线电视、光线、专线等多种通信线路来接入互联网，这些通信线路统称为接入网。接入网连接到签约的网络运营商，并接入被称为接入点（Point ofPresence, PoP）的设备。接入点的实体是一台专为运营商设计的路由器，我们可以把它理解为离你家最近的邮局。从各个邮筒中收集来的信件会在邮局进行分拣，然后被送往全国甚至全世界，互联网也是一样，网络包首先通过接入网被发送到接入点，然后再从这里被发送到全国甚至全世界。接入点的后面就是互联网的骨干部分了。在骨干网中存在很多运营商和大量的路由器，这些路由器相互连接，组成一张巨大的网，而我们的网络包就在其中经过若干路由器的接力，最终被发送到目标 Web 服务器上。它的基本原理和家庭、公司中的路由器是相同的。也就是说，无论是在互联网中，还是在家庭、公司的局域网中，包都是以相同的方式传输的，这也是互联网的一大特征。</li>
<li>防火墙、缓存服务器： 通过骨干网之后，网络包最终到达了 Web 服务器所在的局域网中。接着，它会遇到防火墙，防火墙会对进入的包进行检查。它会检查所有进入的包，看看有没有危险的包混在里面。检查完之后，网络包接下来可能还会遇到缓存服务器。网页数据中有一部分是可以重复利用的，这些可以重复利用的数据就被保存在缓存服务器中。如果要访问的网页数据正好在缓存服务器中能够找到，那么就可以不用劳烦 Web 服务器，直接从缓存服务器读出数据。此外，在大型网站中，可能还会配备将消息分布到多台 Web 服务器上的负载均衡器，还有可能会使用通过分布在整个互联网中的缓存服务器来分发内容的服务。经过这些机制之后，网络包才会到达 Web 服务器。</li>
<li>Web 服务器： 当网络包到达 Web 服务器后，数据会被解包并还原为原始的请求消息，然后交给 Web 服务器程序。和客户端一样，这个操作也是由操作系统中的协议栈（网络控制软件）来完成的。接下来，Web 服务器程序分析请求消息的含义，并按照其中的指示将数据装入响应消息中，然后发回给客户端。响应消息回到客户端的过程和之前我们介绍的过程正好相反。当响应到达客户端之后，浏览器会从中读取出网页的数据并在屏幕上显示出来。到这里，访问 Web 服务器的一系列操作就全部完成了。</li>
</ol>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><h3 id="浏览器生成消息"><a href="#浏览器生成消息" class="headerlink" title="浏览器生成消息"></a>浏览器生成消息</h3><h4 id="HTTP-消息格式"><a href="#HTTP-消息格式" class="headerlink" title="HTTP 消息格式"></a>HTTP 消息格式</h4><ul>
<li>请求行，请求头，请求体</li>
</ul>
<h4 id="DNS-查询"><a href="#DNS-查询" class="headerlink" title="DNS 查询"></a>DNS 查询</h4><ul>
<li>域名的层次结构</li>
<li>递归与迭代查询</li>
<li>使用 UDP</li>
<li>dig、nslookup、host、whois 命令</li>
</ul>
<pre><code>域名解析过程:

1. 操作系统会先检查自己本地的 hosts 文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。
2.如果 hosts 里没有这个域名的映射，则查找本地 DNS 解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。
3.如果 hosts 与本地 DNS 解析器缓存都没有相应的网址映射关系，首先会找 TCP/IP 参数中设置的首选 DNS 服务器，在此我们叫它本地 DNS 服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。
4.如果要查询的域名，不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析，此解析不具有权威性。
5.如果本地 DNS 服务器本地区域文件与缓存解析都失效，则根据本地 DNS 服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地 DNS 就把请求发至 “根 DNS 服务器”，“根 DNS 服务器”收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个 IP。本地 DNS 服务器收到 IP 信息后，将会联系负责.com 域的这台服务器。这台负责.com 域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com 域的下一级 DNS 服务器地址(qq.com)给本地 DNS 服务器。当本地 DNS 服务器收到这个地址后，就会找 qq.com 域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。
6.如果用的是转发模式，此 DNS 服务器就会把请求转发至上一级 DNS 服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上上级，以此循环。

不管是本地 DNS 服务器用是是转发，还是根提示，最后都是把结果返回给本地 DNS 服务器，由此 DNS 服务器再返回给客户机。

递归查询与迭代查询:
一、主机向本地域名服务器的查询一般都是采用递归查询。

所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。

二、本地域名服务器向根域名服务器的查询的迭代查询。

迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。
</code></pre>
<h3 id="协议栈与网卡"><a href="#协议栈与网卡" class="headerlink" title="协议栈与网卡"></a>协议栈与网卡</h3><h4 id="协议栈通过-TCP-协议收发数据分为-4-个阶段。"><a href="#协议栈通过-TCP-协议收发数据分为-4-个阶段。" class="headerlink" title="协议栈通过 TCP 协议收发数据分为 4 个阶段。"></a>协议栈通过 TCP 协议收发数据分为 4 个阶段。</h4><ol>
<li>创建套接字</li>
<li>连接服务器</li>
<li>收发数据</li>
<li>断开并删除套接字</li>
</ol>
<ul>
<li><p>套接字： 在协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的控制信息，例如通信对象的 IP 地址、端口号、通信操作的进行状态等。套接字就只是一个概念而已，并不存在实体，如果一定要赋予它一个实体，我们可以说这些控制信息就是套接字的实体，或者说存放控制信息的内存空间就是套接字的实体。协议栈在执行操作时需要参阅这些控制信息。例如，在发送数据时，需要看一看套接字中的通信对象 IP 地址和端口号，以便向指定的 IP 地址和端口发送数据。在发送数据之后，协议栈需要等待对方返回收到数据的响应信息，但数据也可能在中途丢失，永远也等不到对方的响应。在这样的情况下，我们不能一直等下去，需要在等待一定时间之后重新发送丢失的数据，这就需要协议栈能够知道执行发送数据操作后过了多长时间。为此，套接字中必须要记录是否已经收到响应，以及发送数据后经过了多长时间，才能根据这些信息按照需要执行重发操作。上面说的只是其中一个例子。套接字中记录了用于控制通信操作的各种控制信息，协议栈则需要根据这些信息判断下一步的行动，这就是套接字的作用。协议栈是根据套接字中记录的控制信息来工作的。</p>
</li>
<li><p>连接套接字：协议栈会将本地的套接字与服务器的套接字进行连接。这里的“连接”到底如何理解？连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作。套接字刚刚创建完成的时候，里面并没有存放任何数据，也不知道通信的对象是谁。在这个状态下，即便应用程序要求发送数据，协议栈也不知道数据应该发送给谁。因此，我们需要把服务器的 IP 地址和端口号等信息告知协议栈，这是连接操作的目的之一。同时，我们需要让客户端向服务器告知必要的信息，比如“我想和你开始通信，我的 IP 地址是 xxx.xxx. xxx.xxx，端口号是 yyyy。”可见，客户端向服务器传达开始通信的请求，也是连接操作的目的之一。</p>
</li>
</ul>
<pre><code>注： 使用 netstat 命令可以显示系统中的套接字。

Internet domain socket states(Socket的状态及释义，使用 man netstat 命令获取):

CLOSED:  The socket is not in use.

LISTEN:  The socket is listening for incoming connections.  Unconnected
listening sockets like these are only displayed when using the -a option.

SYN_SENT:  The socket is actively trying to establish a connection to a
remote peer.

SYN_RCVD:  The socket has passively received a connection request from a
remote peer.

ESTABLISHED:  The socket has an established connection between a local
application and a remote peer.

CLOSE_WAIT:  The socket connection has been closed by the remote peer,
and the system is waiting for the local application to close its half of
the connection.

LAST_ACK:  The socket connection has been closed by the remote peer, the
local application has closed its half of the connection, and the system
is waiting for the remote peer to acknowledge the close.

FIN_WAIT_1:  The socket connection has been closed by the local
application, the remote peer has not yet acknowledged the close, and the
system is waiting for it to close its half of the connection.

FIN_WAIT_2:  The socket connection has been closed by the local
application, the remote peer has acknowledged the close, and the system
is waiting for it to close its half of the connection.

CLOSING:  The socket connection has been closed by the local application
and the remote peer simultaneously, and the remote peer has not yet
acknowledged the close attempt of the local application.

TIME_WAIT:  The socket connection has been closed by the local
application, the remote peer has closed its half of the connection, and
the system is waiting to be sure that the remote peer received the last
acknowledgement.
</code></pre>
<ul>
<li>TCP 连接三次握手</li>
</ul>
<p>当 TCP 头部创建好之后，接下来 TCP 模块会将信息传递给 IP 模块并委托它进行发送。IP 模块执行网络包发送操作后，网络包就会通过网络到达服务器，然后服务器上的 IP 模块会将接收到的数据传递给 TCP 模块，服务器的 TCP 模块根据 TCP 头部中的信息找到端口号对应的套接字，也就是说，从处于等待连接状态的套接字中找到与 TCP 头部中记录的端口号相同的套接字就可以了。当找到对应的套接字之后，套接字中会写入相应的信息，并将状态改为正在连接。上述操作完成后，服务器的 TCP 模块会返回响应，这个过程和客户端一样，需要在 TCP 头部中设置发送方和接收方端口号以及 SYN 比特。此外，在返回响应时还需要将 ACK 控制位设为 1，这表示已经接收到相应的网络包。网络中经常会发生错误，网络包也会发生丢失，因此双方在通信时必须相互确认网络包是否已经送达，而设置 ACK 比特就是用来进行这一确认的。接下来，服务器 TCP 模块会将 TCP 头部传递给 IP 模块，并委托 IP 模块向客户端返回响应。</p>
<p>然后，网络包就会返回到客户端，通过 IP 模块到达 TCP 模块，并通过 TCP 头部的信息确认连接服务器的操作是否成功。如果 SYN 为 1 则表示连接成功，这时会向套接字中写入服务器的 IP 地址、端口号等信息，同时还会将状态改为连接完毕。到这里，客户端的操作就已经完成，但其实还剩下最后一个步骤。刚才服务器返回响应时将 ACK 比特设置为 1，相应地，客户端也需要将 ACK 比特设置为 1 并发回服务器，告诉服务器刚才的响应包已经收到。当这个服务器收到这个返回包之后，连接操作才算全部完成。现在，套接字就已经进入随时可以收发数据的状态了，大家可以认为这时有一根管子把两个套接字连接了起来。当然，实际上并不存在这么一根管子，不过这样想比较容易理解，网络业界也习惯这样来描述。这根管子，我们称之为连接。只要数据传输过程在持续，也就是在调用 close 断开之前，连接是一直存在的。</p>
<p>建立连接之后，协议栈的连接操作就结束了，也就是说 connect 已经执行完毕，控制流程被交回到应用程序。</p>
<ul>
<li>数据收发： 协议栈并不是一收到数据就马上发送出去，而是会将数据存放在内部的发送缓冲区中，并等待应用程序的下一段数据。至于要积累多少数据才能发送，不同种类和版本的操作系统会有所不同，不能一概而论，但都是根据下面几个要素来判断的。第一个判断要素是每个网络包能容纳的数据长度，协议栈会根据一个叫作 MTU 的参数来进行判断。MTU 表示一个网络包的最大长度，在以太网中一般是 1500 字节。MTU 是包含头部的总长度，因此需要从 MTU 减去头部的长度，然后得到的长度就是一个网络包中所能容纳的最大数据长度，这一长度叫作 MSS。当从应用程序收到的数据长度超过或者接近 MSS 时再发送出去，就可以避免发送大量小包的问题了。另一个判断要素是时间。当应用程序发送数据的频率不高的时候，如果每次都等到长度接近 MSS 时再发送，可能会因为等待时间太长而造成发送延迟，这种情况下，即便缓冲区中的数据长度没有达到 MSS，也应该果断发送出去。为此，协议栈的内部有一个计时器，当经过一定时间之后，就会把网络包发送出去。判断要素就是这两个，但它们其实是互相矛盾的。如果长度优先，那么网络的效率会提高，但可能会因为等待填满缓冲区而产生延迟；相反地，如果时间优先，那么延迟时间会变少，但又会降低网络的效率。因此，在进行发送操作时需要综合考虑这两个要素以达到平衡。不过，TCP 协议规格中并没有告诉我们怎样才能平衡，因此实际如何判断是由协议栈的开发者来决定的，也正是由于这个原因，不同种类和版本的操作系统在相关操作上也就存在差异。正如前面所说，如果仅靠协议栈来判断发送的时机可能会带来一些问题，因此协议栈也给应用程序保留了控制发送时机的余地。应用程序在发送数据时可以指定一些选项，比如如果指定“不等待填满缓冲区直接发送”，则协议栈就会按照要求直接发送数据(例如 nodejs 中可以通过 socket.setNoDelay 方法来控制是否延迟发送数据)。像浏览器这种会话型的应用程序在向服务器发送数据时，等待填满缓冲区导致延迟会产生很大影响，因此一般会使用直接发送的选项。</li>
</ul>
<p>待发送的数据长度如果超出 MSS，TCP 会按照网络包的大小进行拆分，然后每一段放在一个网络包中发送。TCP 模块在拆分数据时，会先算好每一块数据相当于从头开始的第几个字节，接下来在发送这一块数据时，将算好的字节数写在 TCP 头部中，“序号”字段就是派在这个用场上的。发送数据的长度也需要告知接收方，不过这个并不是放在 TCP 头部里面的，因为用整个网络包的长度减去头部的长度就可以得到数据的长度，所以接收方可以用这种方法来进行计算。有了上面两个数值，我们就可以知道发送的数据是从第几个字节开始，长度是多少了。如果确认没有遗漏，接收方会将到目前为止接收到的数据长度加起来，计算出一共已经收到了多少个字节，然后将这个数值写入 TCP 头部的 ACK 号中发送给发送方。简单来说，发送方说的是“现在发送的是从第 ×× 字节开始的部分，一共有 ×× 字节哦！”而接收方则回复说，“到第 ×× 字节之前的数据我已经都收到了哦！”这个返回 ACK 号的操作被称为确认响应，通过这样的方式，发送方就能够确认对方到底收到了多少数据。在实际的通信中，序号并不是从 1 开始的，而是需要用随机数计算出一个初始值，这是因为如果序号都从 1 开始，通信过程就会非常容易预测，有人会利用这一点来发动攻击。但是如果初始值是随机的，那么对方就搞不清楚序号到底是从多少开始计算的，因此需要在开始收发数据之前将初始值告知通信对象。大家应该还记得在我们刚才讲过的连接过程中，有一个将 SYN 控制位设为 1 并发送给服务器的操作，就是在这一步将序号的初始值告知对方的。实际上，在将 SYN 设为 1 的同时，还需要同时设置序号字段的值，而这里的值就代表序号的初始值（三次握手）。客户端和服务器双方都需要各自计算序号，因此双方需要在连接过程中互相告知自己计算的序号初始值。</p>
<ul>
<li><p>拥塞控制</p>
</li>
<li><p>滑动窗口： 每发送一个包就等待一个 ACK 号的方式是最简单也最容易理解的，但在等待 ACK 号的这段时间中，如果什么都不做那实在太浪费了。为了减少这样的浪费，TCP 采用滑动窗口方式来管理数据发送和 ACK 号的操作。所谓滑动窗口，就是在发送一个包之后，不等待 ACK 号返回，而是直接发送后续的一系列包。这样一来，等待 ACK 号的这段时间就被有效利用起来了。</p>
</li>
</ul>
<h4 id="IP-与以太包收发"><a href="#IP-与以太包收发" class="headerlink" title="IP 与以太包收发"></a>IP 与以太包收发</h4><p>在互联网上传送数据时，数据会被切分成一个一个的网络包，而将网络包发送给通信对象的操作就是由 IP 来负责的。此外，IP 中还包括 ICMP 协议和 ARP 协议。ICMP 用于告知网络包传送过程中产生的错误以及各种控制消息，ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。</p>
<h4 id="UDP-协议收发数据"><a href="#UDP-协议收发数据" class="headerlink" title="UDP 协议收发数据"></a>UDP 协议收发数据</h4><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/36502282">彻底揭开“从 URL 到页面展现发生了什么”的秘密</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2016/06/dns.html">DNS 原理入门-阮一峰！！！</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
